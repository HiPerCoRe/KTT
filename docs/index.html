<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kernel Tuning Toolkit: KTT - Kernel Tuning Toolkit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kernel Tuning Toolkit<span id="projectnumber">&#160;2.2</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">KTT - Kernel Tuning Toolkit </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__readme"></a> <img src="https://github.com/HiPerCoRe/KTT/blob/master/docs/Resources/KttLogoColor.png" alt="" width="425" height="150" class="inline"/></p>
<p>KTT is an autotuning framework for <b>OpenCL</b>, <b>CUDA</b> kernels and experimental support for <b>GLSL</b> compute shaders. It primarily focus to GPU accelerators, but can be used to auto-tune also code for different devices (e.g., CPUs) when OpenCL is utilized. KTT core is implemented in C++, but version 2.2 allows its usage from Python or loading autotuning configurations from JSON files. The C++ core brings high performance, low latency, and allows dynamic tuning (i.e., autotuning during application runtime).</p>
<h1>Main features </h1>
<ul>
<li>Ability to define kernel tuning parameters such as kernel thread block sizes, vector data types and loop unroll factors to optimize computation for a particular device.</li>
<li>Support for iterative kernel launches and composite kernels, allowing sharing tuning parameters among multiple kernels (e.g., layout of intermediate date).</li>
<li>Support for multiple compute queues and asynchronous operations.</li>
<li>Support for dynamic auto-tuning - kernel tuning combined with regular kernel running.</li>
<li>Ability to automatically ensure the correctness of tuned computation with reference kernel or C++ function.</li>
<li>Support for multiple compute APIs, switching between CUDA, OpenCL and Vulkan requires only minor changes in C++ code (e.g., changing the kernel source file), no library recompilation is needed.</li>
<li>Public API available in C++ (native) and Python (bindings), tuning configuration can be loaded from JSON, allowing interoperability with other autotuning frameworks (so far <a href="https://github.com/KernelTuner/kernel_tuner">Kernel Tuner</a>).</li>
<li>Advanced profile-based searcher, laveraging hardware performance counters and machine learning to navigate tuning spaces quickly.</li>
<li>Mearuring energy consumption with CUDA devices.</li>
<li>Many customization options, including support for kernel arguments with user-defined data types, ability to change kernel compiler flags and more.</li>
</ul>
<h1>Getting started </h1>
<ul>
<li>Introductory guide to KTT can be found <a href="https://github.com/HiPerCoRe/KTT/blob/master/OnboardingGuide.md">here</a>.</li>
<li>Full documentation for KTT API can be found <a href="https://hipercore.github.io/KTT/">here</a>.</li>
<li>KTT FAQ can be found <a href="https://hipercore.github.io/KTT/md__docs__resources__faq.html">here</a>.</li>
<li>The newest release of the KTT framework can be found <a href="https://github.com/HiPerCoRe/KTT/releases">here</a>.</li>
<li>Prebuilt binaries are not provided due to many different combinations of compute APIs and build options available. The <code>Building KTT</code> section contains detailed instructions on how to perform a build.</li>
</ul>
<h1>Tutorials </h1>
<p>Tutorials are short examples that serve as an introduction to the KTT framework. Each tutorial covers a specific part of the API. All tutorials are available for both OpenCL and CUDA backends. Most of the tutorials are also available for Vulkan. Tutorials assume that the reader has some knowledge about C++ and GPU programming. List of the currently available tutorials:</p>
<ul>
<li><code>Info</code>: Retrieving information about compute API platforms and devices through KTT API.</li>
<li><code>KernelRunning</code>: Running simple kernel with KTT framework and retrieving output.</li>
<li><code>KernelTuning</code>: Simple kernel tuning using a small number of tuning parameters and reference computation to validate output.</li>
<li><code>CustomArgumentTypes</code>: Usage of kernel arguments with custom data types and validating the output with value comparator.</li>
<li><code>ComputeApiInitializer</code>: Providing tuner with custom compute context, queues and buffers.</li>
<li><code>VectorArgumentCustomization</code>: Showcasing different usage options for vector kernel arguments.</li>
<li><code>PythonInterfaces</code>: Implementing custom searchers and stop conditions in Python, which can afterward be used with the tuner.</li>
</ul>
<h1>Examples </h1>
<p>Examples showcase how the KTT framework could be utilized in real-world scenarios. They are more complex than tutorials and assume that the reader is familiar with KTT API. List of some of the currently available examples:</p>
<ul>
<li><code>CoulombSum2d</code>: Tuning of electrostatic potential map computation, focuses on a single slice.</li>
<li><code>CoulombSum3dIterative</code>: 3D version of the previous example, utilizes kernel from 2D version and launches it iteratively.</li>
<li><code>CoulombSum3d</code>: Alternative to iterative version, utilizes kernel which computes the entire map in a single invocation.</li>
<li><code>Nbody</code>: Tuning of N-body simulation.</li>
<li><code>Reduction</code>: Tuning of vector reduction, launches a kernel iteratively.</li>
<li><code>Sort</code>: Radix sort example, combines multiple kernels into a composite kernel.</li>
<li><code>Bicg</code>: Biconjugate gradients method example, features reference computation, composite kernels and constraints.</li>
</ul>
<h1>Building KTT </h1>
<ul>
<li>KTT can be built as a dynamic (shared) library using the command line build tool Premake. Currently supported operating systems are Linux and Windows.</li>
<li>The prerequisites to build KTT are:<ul>
<li>C++17 compiler, for example Clang 7.0, GCC 9.1, MSVC 14.16 (Visual Studio 2017) or newer</li>
<li>OpenCL, CUDA or Vulkan library, supported SDKs are AMD OCL SDK, Intel SDK for OpenCL, NVIDIA CUDA Toolkit and Vulkan SDK</li>
<li>Command line build tool <a href="https://premake.github.io/download">Premake 5</a></li>
<li>(Optional) Python 3 with NumPy for Python bindings support</li>
<li>(Optional) NVIDIA CUPTI, or AMD GPU Performance API for profiling and profile-based searcher</li>
</ul>
</li>
<li>Build under Linux (inside KTT root folder):<ul>
<li>ensure that path to vendor SDK is correctly set in the environment variables</li>
<li>run <code>./premake5 gmake</code> to generate makefile</li>
<li>run <code>cd Build</code> to get inside the build directory</li>
<li>afterwards run <code>make config={configuration}_{architecture}</code> to build the project (e.g., <code>make config=release_x86_64</code>)</li>
</ul>
</li>
<li>Build under Windows (inside KTT root folder):<ul>
<li>ensure that path to vendor SDK is correctly set in the environment variables; this should be done automatically during SDK installation</li>
<li>run <code>premake5.exe vs20xx</code> (e.g., <code>premake5.exe vs2019</code>) to generate Visual Studio project files</li>
<li>open generated solution file and build the project inside Visual Studio</li>
</ul>
</li>
<li>The following build options are available:<ul>
<li><code>--outdir=path</code> Specifies custom build directory. The default build directory is <code>Build</code>.</li>
<li><code>--platform=vendor</code> Specifies SDK used for building KTT. May be useful when multiple SDKs are installed.</li>
<li><code>--profiling=library</code> Enables compilation of kernel profiling functionality using the specified library.</li>
<li><code>--power-usage</code> Enables compilation of device power usage collection functionality. This feature is currently supported only on Nvidia platform.</li>
<li><code>--vulkan</code> Enables compilation of experimental Vulkan backend.</li>
<li><code>--python</code> Enables compilation of Python bindings.</li>
<li><code>--tuning-loader</code> Enables compilation of tuning loader, loading tuning settings from JSON.</li>
<li><code>--power-usage</code> Enables measuring power and energy consumption.</li>
<li><code>--power-usage-repeats=repeats</code> Experimental. Sets how many times are kernel repeated to obtain reliable power measurement (the kernel runtime should be around 1/10s).</li>
<li><code>--no-examples</code> Disables compilation of examples.</li>
<li><code>--no-tutorials</code> Disables compilation of tutorials.</li>
<li><code>--tests</code> Enables compilation of unit tests.</li>
<li><code>--no-cuda</code> Disables the inclusion of CUDA API during compilation. Only affects Nvidia platform.</li>
<li><code>--no-opencl</code> Disables the inclusion of OpenCL API during compilation.</li>
</ul>
</li>
<li>KTT rely on external dynamic (shared) libraries to work correctly. There are multiple ways to provide access to these libraries, e.g., copying a given library inside the application folder or adding the containing folder to the library path (example for Linux: <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/shared/library</code>). Libraries which are bundled with device drivers are usually visible by default. The list of libraries currently utilized by KTT (typically nor all libraries are required, depending on settings of the premake5 execution):<ul>
<li><code>OpenCL</code> distributed with specific device drivers (OpenCL only)</li>
<li><code>cuda</code> distributed with specific device drivers (CUDA only)</li>
<li><code>nvrtc</code> distributed with specific device drivers (CUDA only)</li>
<li><code>cupti</code> bundled with Nvidia CUDA Toolkit (CUDA profiling only)</li>
<li><code>nvperf_host</code> bundled with Nvidia CUDA Toolkit (new CUDA profiling only)</li>
<li><code>nvperf_target</code> bundled with Nvidia CUDA Toolkit (new CUDA profiling only)</li>
<li><code>GPUPerfAPICL</code> bundled with KTT distribution (AMD OpenCL profiling only)</li>
<li><code>vulkan</code> distributed with specific device drivers (Vulkan only)</li>
<li><code>shaderc_shared</code> bundled with Vulkan SDK (Vulkan only)</li>
</ul>
</li>
</ul>
<h1>Using KTT in user's applications </h1>
<p>Applications using KTT need to link KTT dynamic library and include KTT headers.</p>
<ul>
<li>Application has to include <code><a class="el" href="_ktt_8h.html">Ktt.h</a></code> (located in <code>KTT/Source</code> folder)</li>
<li>During application build, KTT headers have to be available, e.g., by copying them into standard headers location, or by passing their position to the compiler (by, e.g., <code>-Ilocation_of_my_KTT/Source</code> with g++)</li>
<li>During application build, KTT library has to be linked, e.g., by <code>-lktt</code>, or <code>-Llocation_of_my_KTT/Build/x86_64_Release/ -lktt</code>. KTT dynamic library can be also copied into standard location of dynamic libraries (e.g., <code>/usr/lib</code>).</li>
<li>During application execution, KTT library have to be available (e.g., located in the application's folder, in standard location for dynamic libraries, or any place included in corresponding environmental variable, such as <code>LD_LIBRARY_PATH</code>)</li>
</ul>
<h1>Python bindings </h1>
<p>To be able to use KTT Python API, the KTT module must be built with <code>--python</code> option. For the build option to work, access to Python development headers and library must be provided under environment variables <code>PYTHON_HEADERS</code> and <code>PYTHON_LIB</code> respectively. Once the build is finished, in addition to the regular C++ module, a Python module will be created (named <code>pyktt.pyd</code> under Windows, <code>pyktt.so</code> under Linux). This module can be imported into Python programs in the same way as regular modules. Note that Python must have access to all modules which depend on the KTT module (e.g., various profiling libraries), otherwise the loading will fail.</p>
<h1>Related projects </h1>
<p>KTT API is based on <a href="https://github.com/CNugteren/CLTune">CLTune project</a>. Certain parts of the API are similar to CLTune. However, the internal structure is completely rewritten from scratch. The ClTuneGemm and ClTuneConvolution examples are adopted from CLTune.</p>
<p>KTT search space generation and tuning configuration storage techniques are derived from <a href="https://dl.acm.org/doi/10.1145/3427093">ATF project</a>. Due to differences in API and available framework features, certain modifications were made to the original ATF algorithms. The examples stored in AtfSamples folder are adopted from ATF.</p>
<p>We develop unified JSON input for tuning configurations and output of tuning results with <a href="https://github.com/KernelTuner/kernel_tuner">Kernel Tuner</a>. Unifying input and output allows interoperability between our tuners.</p>
<h1>How to cite </h1>
<p>F. Petrovič et al. <a href="https://www.sciencedirect.com/science/article/abs/pii/S0167739X19327360">A benchmark set of highly-efficient CUDA and OpenCL kernels and its dynamic autotuning with Kernel Tuning Toolkit</a>. In Future Generation Computer Systems, Volume 108, 2020. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
