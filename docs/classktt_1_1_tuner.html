<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kernel Tuning Toolkit: ktt::Tuner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kernel Tuning Toolkit<span id="projectnumber">&#160;2.1</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classktt_1_1_tuner.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classktt_1_1_tuner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ktt::Tuner Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_tuner_8h_source.html">Tuner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63c326b21d847e1ec8d2d63cfb2bb698"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a63c326b21d847e1ec8d2d63cfb2bb698">Tuner</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform, const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a> device, const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a> api)</td></tr>
<tr class="separator:a63c326b21d847e1ec8d2d63cfb2bb698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6039192d8740b2a457479e584cdc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a86b6039192d8740b2a457479e584cdc8">Tuner</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform, const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a> device, const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a> api, const uint32_t computeQueueCount)</td></tr>
<tr class="separator:a86b6039192d8740b2a457479e584cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04863df669de4665b5687174ef53908d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a04863df669de4665b5687174ef53908d">Tuner</a> (const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a> api, const <a class="el" href="classktt_1_1_compute_api_initializer.html">ComputeApiInitializer</a> &amp;initializer)</td></tr>
<tr class="separator:a04863df669de4665b5687174ef53908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704d563ca882d602f1f4e374fe03fb19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a704d563ca882d602f1f4e374fe03fb19">Tuner</a> (const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a> api, const <a class="el" href="classktt_1_1_compute_api_initializer.html">ComputeApiInitializer</a> &amp;initializer, std::vector&lt; <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> &gt; &amp;assignedQueueIds)</td></tr>
<tr class="separator:a704d563ca882d602f1f4e374fe03fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09198b07768176d263dbee8a6c54b377"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a09198b07768176d263dbee8a6c54b377">~Tuner</a> ()</td></tr>
<tr class="separator:a09198b07768176d263dbee8a6c54b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d47480e40733abfad1780f599a4be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a98d47480e40733abfad1780f599a4be8">AddKernelDefinition</a> (const std::string &amp;name, const std::string &amp;source, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize, const std::vector&lt; std::string &gt; &amp;typeNames={})</td></tr>
<tr class="separator:a98d47480e40733abfad1780f599a4be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c8e80a4eefa9dd00b475b237a40e9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ad3c8e80a4eefa9dd00b475b237a40e9b">AddKernelDefinitionFromFile</a> (const std::string &amp;name, const std::string &amp;filePath, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize, const std::vector&lt; std::string &gt; &amp;typeNames={})</td></tr>
<tr class="separator:ad3c8e80a4eefa9dd00b475b237a40e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db4f79c0e1d7cc2e2eb3e194e6a0cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a9db4f79c0e1d7cc2e2eb3e194e6a0cb8">GetKernelDefinitionId</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;typeNames={}) const</td></tr>
<tr class="separator:a9db4f79c0e1d7cc2e2eb3e194e6a0cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789c4c550bd615bda43afd152d410b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a789c4c550bd615bda43afd152d410b6c">RemoveKernelDefinition</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id)</td></tr>
<tr class="separator:a789c4c550bd615bda43afd152d410b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2b24bebe7d9408c947c30f9471966d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a1c2b24bebe7d9408c947c30f9471966d">SetArguments</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;argumentIds)</td></tr>
<tr class="separator:a1c2b24bebe7d9408c947c30f9471966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136a3e45466bc0434484b06ae338c3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a136a3e45466bc0434484b06ae338c3cc">CreateSimpleKernel</a> (const std::string &amp;name, const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> definitionId)</td></tr>
<tr class="separator:a136a3e45466bc0434484b06ae338c3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a99601a2d8876cecb6a5455a55e8c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a1a99601a2d8876cecb6a5455a55e8c1e">CreateCompositeKernel</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;definitionIds, <a class="el" href="namespacektt.html#afd0d71d6fa61d6a1660bf233ae1df2ac">KernelLauncher</a> launcher=nullptr)</td></tr>
<tr class="separator:a1a99601a2d8876cecb6a5455a55e8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f62e176f33adafdde70dd077fb9e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a95f62e176f33adafdde70dd077fb9e88">RemoveKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)</td></tr>
<tr class="separator:a95f62e176f33adafdde70dd077fb9e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17f07f5fa61fcfcd9dbe77068209992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#af17f07f5fa61fcfcd9dbe77068209992">SetLauncher</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, <a class="el" href="namespacektt.html#afd0d71d6fa61d6a1660bf233ae1df2ac">KernelLauncher</a> launcher)</td></tr>
<tr class="separator:af17f07f5fa61fcfcd9dbe77068209992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf79f9092d20f151b7d9690ffbdfc8ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aaf79f9092d20f151b7d9690ffbdfc8ff">AddParameter</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;name, const std::vector&lt; uint64_t &gt; &amp;values, const std::string &amp;group=&quot;&quot;)</td></tr>
<tr class="separator:aaf79f9092d20f151b7d9690ffbdfc8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805fb0026bbd0e2787b75ea058d1f10f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a805fb0026bbd0e2787b75ea058d1f10f">AddParameter</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;name, const std::vector&lt; double &gt; &amp;values, const std::string &amp;group=&quot;&quot;)</td></tr>
<tr class="separator:a805fb0026bbd0e2787b75ea058d1f10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa5b962d4742ff4aa70171a990a3dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#adfaa5b962d4742ff4aa70171a990a3dd">AddThreadModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;definitionIds, const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> type, const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> dimension, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="namespacektt.html#ad8b6453e21ff3d1bf4208886d9af8810">ModifierFunction</a> function)</td></tr>
<tr class="separator:adfaa5b962d4742ff4aa70171a990a3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34ed21ac3bdfd2421f7ba0abe62aa7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa34ed21ac3bdfd2421f7ba0abe62aa7b">AddThreadModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;definitionIds, const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> type, const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> dimension, const std::string &amp;parameter, const <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a> action)</td></tr>
<tr class="separator:aa34ed21ac3bdfd2421f7ba0abe62aa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfc141a0f3d3dbb237a76c394d760b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a5cfc141a0f3d3dbb237a76c394d760b8">AddConstraint</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="namespacektt.html#a60f871f057714181e6e88faf66d838b3">ConstraintFunction</a> function)</td></tr>
<tr class="separator:a5cfc141a0f3d3dbb237a76c394d760b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9ed472e7c2bd1b01799bf37802c796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a6d9ed472e7c2bd1b01799bf37802c796">SetProfiledDefinitions</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;definitionIds)</td></tr>
<tr class="separator:a6d9ed472e7c2bd1b01799bf37802c796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8fdad5788a9f1c6bb71b731c17d89c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a8fdad5788a9f1c6bb71b731c17d89c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a4a8fdad5788a9f1c6bb71b731c17d89c">AddArgumentVector</a> (const std::vector&lt; T &gt; &amp;data, const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> accessType)</td></tr>
<tr class="separator:a4a8fdad5788a9f1c6bb71b731c17d89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3b932d8a87ff1e2a20b1c791af38dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b3b932d8a87ff1e2a20b1c791af38dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a2b3b932d8a87ff1e2a20b1c791af38dc">AddArgumentVector</a> (std::vector&lt; T &gt; &amp;data, const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> accessType, const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> memoryLocation, const <a class="el" href="namespacektt.html#a6c3eb24a8cdc991dd7b7274cc340852f">ArgumentManagementType</a> managementType, const bool referenceUserData)</td></tr>
<tr class="separator:a2b3b932d8a87ff1e2a20b1c791af38dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74cb565dee534d538c85d2d57a4b3f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa74cb565dee534d538c85d2d57a4b3f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa74cb565dee534d538c85d2d57a4b3f5">AddArgumentVector</a> (<a class="el" href="namespacektt.html#ab65fcc4157cfe64ccd1d00b177ccb5af">ComputeBuffer</a> buffer, const size_t bufferSize, const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> accessType, const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> memoryLocation)</td></tr>
<tr class="separator:aa74cb565dee534d538c85d2d57a4b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b8bb17df50309173a07303fb1b10a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a34b8bb17df50309173a07303fb1b10a7">AddArgumentVector</a> (<a class="el" href="namespacektt.html#ab65fcc4157cfe64ccd1d00b177ccb5af">ComputeBuffer</a> buffer, const size_t bufferSize, const size_t elementSize, const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> accessType, const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> memoryLocation)</td></tr>
<tr class="separator:a34b8bb17df50309173a07303fb1b10a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aafe5e4d2e7d89fb1a59ad9069e3f88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8aafe5e4d2e7d89fb1a59ad9069e3f88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a8aafe5e4d2e7d89fb1a59ad9069e3f88">AddArgumentScalar</a> (const T &amp;data)</td></tr>
<tr class="separator:a8aafe5e4d2e7d89fb1a59ad9069e3f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0014a51fff4d963f7eccba50ae4ecb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a0014a51fff4d963f7eccba50ae4ecb28">AddArgumentScalar</a> (const void *data, const size_t dataSize)</td></tr>
<tr class="separator:a0014a51fff4d963f7eccba50ae4ecb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1f558e170b15a155be9c7fac64d3a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f1f558e170b15a155be9c7fac64d3a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a7f1f558e170b15a155be9c7fac64d3a2">AddArgumentLocal</a> (const size_t localMemorySize)</td></tr>
<tr class="separator:a7f1f558e170b15a155be9c7fac64d3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45fabe98321bfe3f51bf5011897c69e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af45fabe98321bfe3f51bf5011897c69e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#af45fabe98321bfe3f51bf5011897c69e">AddArgumentSymbol</a> (const T &amp;data, const std::string &amp;symbolName=&quot;&quot;)</td></tr>
<tr class="separator:af45fabe98321bfe3f51bf5011897c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9243c05712e47d182385b2e097403ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a9243c05712e47d182385b2e097403ea5">RemoveArgument</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id)</td></tr>
<tr class="separator:a9243c05712e47d182385b2e097403ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab906111fbc44d2a7be1afad5c9b131a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ab906111fbc44d2a7be1afad5c9b131a1">SetReadOnlyArgumentCache</a> (const bool flag)</td></tr>
<tr class="separator:ab906111fbc44d2a7be1afad5c9b131a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ced5f956d194f95d1eab209c0da355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a78ced5f956d194f95d1eab209c0da355">Run</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;configuration, const std::vector&lt; <a class="el" href="classktt_1_1_buffer_output_descriptor.html">BufferOutputDescriptor</a> &gt; &amp;output)</td></tr>
<tr class="separator:a78ced5f956d194f95d1eab209c0da355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005ffd8e117b1f6f6a564bdbe53e33ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a005ffd8e117b1f6f6a564bdbe53e33ca">SetProfiling</a> (const bool flag)</td></tr>
<tr class="separator:a005ffd8e117b1f6f6a564bdbe53e33ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddedf54b28a454e347f0d40d4c57185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a0ddedf54b28a454e347f0d40d4c57185">SetValidationMethod</a> (const <a class="el" href="namespacektt.html#a187d4987bb48bc1f78f628c8aa840a20">ValidationMethod</a> method, const double toleranceThreshold)</td></tr>
<tr class="separator:a0ddedf54b28a454e347f0d40d4c57185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e12637ab4df58139ce03161f6a9a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a77e12637ab4df58139ce03161f6a9a47">SetValidationMode</a> (const <a class="el" href="namespacektt.html#a3baf318a03750f7418a5faa051967c04">ValidationMode</a> mode)</td></tr>
<tr class="separator:a77e12637ab4df58139ce03161f6a9a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0a53f0d54ac5a285b40386ec5a39a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a8d0a53f0d54ac5a285b40386ec5a39a4">SetValidationRange</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const size_t range)</td></tr>
<tr class="separator:a8d0a53f0d54ac5a285b40386ec5a39a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385b67cfa5ac085f540fe21c1f461bf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a385b67cfa5ac085f540fe21c1f461bf2">SetValueComparator</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, <a class="el" href="namespacektt.html#ab2cf30aab952f8ea4366979237f9e1e9">ValueComparator</a> comparator)</td></tr>
<tr class="separator:a385b67cfa5ac085f540fe21c1f461bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966c08e5ca21c2731288a7b2eb3b1229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a966c08e5ca21c2731288a7b2eb3b1229">SetReferenceComputation</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, <a class="el" href="namespacektt.html#aa072e8ed2d94052fbb5686b3ff75878f">ReferenceComputation</a> computation)</td></tr>
<tr class="separator:a966c08e5ca21c2731288a7b2eb3b1229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044c7e763c75254ddb25ba53a749dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a1044c7e763c75254ddb25ba53a749dd9">SetReferenceKernel</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> referenceId, const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;configuration)</td></tr>
<tr class="separator:a1044c7e763c75254ddb25ba53a749dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed0d38ea099aef96218bd95a98e8a06"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a7ed0d38ea099aef96218bd95a98e8a06">Tune</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)</td></tr>
<tr class="separator:a7ed0d38ea099aef96218bd95a98e8a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16040c3a6f5603ef337ef4a7057f9b69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a16040c3a6f5603ef337ef4a7057f9b69">Tune</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, std::unique_ptr&lt; <a class="el" href="classktt_1_1_stop_condition.html">StopCondition</a> &gt; stopCondition)</td></tr>
<tr class="separator:a16040c3a6f5603ef337ef4a7057f9b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98c514e83ad83f0ecffb7f1e4b48e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ab98c514e83ad83f0ecffb7f1e4b48e34">TuneIteration</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="classktt_1_1_buffer_output_descriptor.html">BufferOutputDescriptor</a> &gt; &amp;output, const bool recomputeReference=false)</td></tr>
<tr class="separator:ab98c514e83ad83f0ecffb7f1e4b48e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0bb2189bf6c1210c42b0f1ddd93399"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#acf0bb2189bf6c1210c42b0f1ddd93399">SimulateKernelTuning</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; &amp;results, const uint64_t iterations=0)</td></tr>
<tr class="separator:acf0bb2189bf6c1210c42b0f1ddd93399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff564535e11125821fb39b1bd863fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aaff564535e11125821fb39b1bd863fdb">SetSearcher</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, std::unique_ptr&lt; <a class="el" href="classktt_1_1_searcher.html">Searcher</a> &gt; searcher)</td></tr>
<tr class="separator:aaff564535e11125821fb39b1bd863fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87f966ad499bd35c2c7526574a7ed34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa87f966ad499bd35c2c7526574a7ed34">ClearData</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)</td></tr>
<tr class="separator:aa87f966ad499bd35c2c7526574a7ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360361884d6c490d557d9926da3b813d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a360361884d6c490d557d9926da3b813d">GetBestConfiguration</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id) const</td></tr>
<tr class="separator:a360361884d6c490d557d9926da3b813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c5696b3aac3ff9892df7ebbb7022e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a888c5696b3aac3ff9892df7ebbb7022e">CreateConfiguration</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#aef951ec46e383694c8512ddaa6b200d6">ParameterInput</a> &amp;parameters) const</td></tr>
<tr class="separator:a888c5696b3aac3ff9892df7ebbb7022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa014f51574f99a828f040895290f3f4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#afa014f51574f99a828f040895290f3f4">GetKernelSource</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;configuration) const</td></tr>
<tr class="separator:afa014f51574f99a828f040895290f3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f0185c96bcc8f54b1b9deb9d6b4d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a226f0185c96bcc8f54b1b9deb9d6b4d8">GetKernelDefinitionSource</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;configuration) const</td></tr>
<tr class="separator:a226f0185c96bcc8f54b1b9deb9d6b4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6711abae75fff387e8083af75dc79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a5ac6711abae75fff387e8083af75dc79">SaveResults</a> (const std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; &amp;results, const std::string &amp;filePath, const <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a> format, const <a class="el" href="namespacektt.html#af9cd5c78192f75cafc2a66b8942868bb">UserData</a> &amp;data={}) const</td></tr>
<tr class="separator:a5ac6711abae75fff387e8083af75dc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870dcea68c8006b1ca92c90171018b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a5870dcea68c8006b1ca92c90171018b4">LoadResults</a> (const std::string &amp;filePath, const <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a> format) const</td></tr>
<tr class="separator:a5870dcea68c8006b1ca92c90171018b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2675eb66dd12edc676df06e4a6db5a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a0e2675eb66dd12edc676df06e4a6db5a">LoadResults</a> (const std::string &amp;filePath, const <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a> format, <a class="el" href="namespacektt.html#af9cd5c78192f75cafc2a66b8942868bb">UserData</a> &amp;data) const</td></tr>
<tr class="separator:a0e2675eb66dd12edc676df06e4a6db5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9894503f98831c5c3f391c5bb5729ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a9894503f98831c5c3f391c5bb5729ed4">AddComputeQueue</a> (<a class="el" href="namespacektt.html#a9a45ee3a893226dc9802b5cae9e6dff5">ComputeQueue</a> queue)</td></tr>
<tr class="separator:a9894503f98831c5c3f391c5bb5729ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016ef58ab7ade647bf93fa43808c78e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a2016ef58ab7ade647bf93fa43808c78e">RemoveComputeQueue</a> (const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> id)</td></tr>
<tr class="separator:a2016ef58ab7ade647bf93fa43808c78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bfecb3a7da093420dcff86ff3a235f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a42bfecb3a7da093420dcff86ff3a235f">WaitForComputeAction</a> (const <a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a> id)</td></tr>
<tr class="separator:a42bfecb3a7da093420dcff86ff3a235f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e8f697b84556c3164575897f7f891a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a32e8f697b84556c3164575897f7f891a">WaitForTransferAction</a> (const <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a> id)</td></tr>
<tr class="separator:a32e8f697b84556c3164575897f7f891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f056f4076db595826eea1bdbacbcdcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a9f056f4076db595826eea1bdbacbcdcb">SynchronizeQueue</a> (const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> id)</td></tr>
<tr class="separator:a9f056f4076db595826eea1bdbacbcdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cc2c4aac72510f028ada44a0283fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ad1cc2c4aac72510f028ada44a0283fab">SynchronizeQueues</a> ()</td></tr>
<tr class="separator:ad1cc2c4aac72510f028ada44a0283fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e76c15db1d25743288ebccd67df3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa38e76c15db1d25743288ebccd67df3b">SynchronizeDevice</a> ()</td></tr>
<tr class="separator:aa38e76c15db1d25743288ebccd67df3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8667aa5703517c100b261a23eed0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a0c8667aa5703517c100b261a23eed0dd">Synchronize</a> ()</td></tr>
<tr class="separator:a0c8667aa5703517c100b261a23eed0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a9ca12b75ea217b0a7f9f68e28639a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ab5a9ca12b75ea217b0a7f9f68e28639a">SetProfilingCounters</a> (const std::vector&lt; std::string &gt; &amp;counters)</td></tr>
<tr class="separator:ab5a9ca12b75ea217b0a7f9f68e28639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cce9a3ee4f44f2e7dbd4e01fc4d9d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a6cce9a3ee4f44f2e7dbd4e01fc4d9d4b">SetCompilerOptions</a> (const std::string &amp;options)</td></tr>
<tr class="separator:a6cce9a3ee4f44f2e7dbd4e01fc4d9d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c985b64a88a2b66835c4afa9fdc8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#abd1c985b64a88a2b66835c4afa9fdc8f">SetGlobalSizeType</a> (const <a class="el" href="namespacektt.html#a16e643cd2325370c79affaeee8ef85f0">GlobalSizeType</a> type)</td></tr>
<tr class="separator:abd1c985b64a88a2b66835c4afa9fdc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95025e0f39526e756a947e953afd9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a7e95025e0f39526e756a947e953afd9a">SetAutomaticGlobalSizeCorrection</a> (const bool flag)</td></tr>
<tr class="separator:a7e95025e0f39526e756a947e953afd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018e398312c674b8aca5e7fbfa128871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a018e398312c674b8aca5e7fbfa128871">SetKernelCacheCapacity</a> (const uint64_t capacity)</td></tr>
<tr class="separator:a018e398312c674b8aca5e7fbfa128871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c02e27e4f5631fa2b45d6ed9f7edea1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_platform_info.html">PlatformInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a5c02e27e4f5631fa2b45d6ed9f7edea1">GetPlatformInfo</a> () const</td></tr>
<tr class="separator:a5c02e27e4f5631fa2b45d6ed9f7edea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc8f3f6cca5a25c91a26a78d1581e3f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a4bc8f3f6cca5a25c91a26a78d1581e3f">GetDeviceInfo</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform) const</td></tr>
<tr class="separator:a4bc8f3f6cca5a25c91a26a78d1581e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08f0fef2d05fd93913f6a461c8d77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a3a08f0fef2d05fd93913f6a461c8d77a">GetCurrentDeviceInfo</a> () const</td></tr>
<tr class="separator:a3a08f0fef2d05fd93913f6a461c8d77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a65b9a2ebdc68c3edc6c9102354f2dcd8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a65b9a2ebdc68c3edc6c9102354f2dcd8">SetTimeUnit</a> (const <a class="el" href="namespacektt.html#a161b9af8714615ef2c1770b020ce1511">TimeUnit</a> unit)</td></tr>
<tr class="separator:a65b9a2ebdc68c3edc6c9102354f2dcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8503c25c10dc31b9e15e56d7a597856d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a8503c25c10dc31b9e15e56d7a597856d">SetLoggingLevel</a> (const <a class="el" href="namespacektt.html#a17afdb449e82292a32fba46ff7a54781">LoggingLevel</a> level)</td></tr>
<tr class="separator:a8503c25c10dc31b9e15e56d7a597856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89be1d46163994257094765fc398fac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ab89be1d46163994257094765fc398fac">SetLoggingTarget</a> (std::ostream &amp;outputTarget)</td></tr>
<tr class="separator:ab89be1d46163994257094765fc398fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af135d787110cbbc19bc66def1b705b4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#af135d787110cbbc19bc66def1b705b4e">SetLoggingTarget</a> (const std::string &amp;filePath)</td></tr>
<tr class="separator:af135d787110cbbc19bc66def1b705b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class which serves as the main part of public API of KTT framework. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63c326b21d847e1ec8d2d63cfb2bb698" name="a63c326b21d847e1ec8d2d63cfb2bb698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c326b21d847e1ec8d2d63cfb2bb698">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a>&#160;</td>
          <td class="paramname"><em>api</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates tuner for the specified platform, device and compute API. All compute commands are submitted to a single queue. Indices for available platforms and devices can be retrieved by using <a class="el" href="classktt_1_1_tuner.html#a5c02e27e4f5631fa2b45d6ed9f7edea1">GetPlatformInfo()</a> and <a class="el" href="classktt_1_1_tuner.html#a4bc8f3f6cca5a25c91a26a78d1581e3f">GetDeviceInfo()</a> methods. If the specified compute API is CUDA or Vulkan, platform index is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index for platform used by the tuner. </td></tr>
    <tr><td class="paramname">device</td><td>Index for device used by the tuner. </td></tr>
    <tr><td class="paramname">api</td><td>Compute API used by the tuner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86b6039192d8740b2a457479e584cdc8" name="a86b6039192d8740b2a457479e584cdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b6039192d8740b2a457479e584cdc8">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a>&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>computeQueueCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates tuner for the specified platform, device and compute API. Multiple compute queues can be created, based on the specified count. Compute commands to different queues can be submitted by utilizing KernelLauncher and <a class="el" href="classktt_1_1_compute_interface.html">ComputeInterface</a>. Indices for available platforms and devices can be retrieved by using <a class="el" href="classktt_1_1_tuner.html#a5c02e27e4f5631fa2b45d6ed9f7edea1">GetPlatformInfo()</a> and <a class="el" href="classktt_1_1_tuner.html#a4bc8f3f6cca5a25c91a26a78d1581e3f">GetDeviceInfo()</a> methods. If the specified compute API is CUDA or Vulkan, platform index is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index for platform used by the tuner. </td></tr>
    <tr><td class="paramname">device</td><td>Index for device used by the tuner. </td></tr>
    <tr><td class="paramname">api</td><td>Compute API used by the tuner. </td></tr>
    <tr><td class="paramname">computeQueueCount</td><td>Number of compute queues created inside the tuner. Has to be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04863df669de4665b5687174ef53908d" name="a04863df669de4665b5687174ef53908d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04863df669de4665b5687174ef53908d">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a>&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_compute_api_initializer.html">ComputeApiInitializer</a> &amp;&#160;</td>
          <td class="paramname"><em>initializer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates tuner for the specified compute API using custom initializer. The initializer contains user-provided compute device context and queues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>Compute API used by the tuner. </td></tr>
    <tr><td class="paramname">initializer</td><td>Custom compute API initializer. See <a class="el" href="classktt_1_1_compute_api_initializer.html">ComputeApiInitializer</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a704d563ca882d602f1f4e374fe03fb19" name="a704d563ca882d602f1f4e374fe03fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704d563ca882d602f1f4e374fe03fb19">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a9738ef47337610739add496ce522de0a">ComputeApi</a>&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_compute_api_initializer.html">ComputeApiInitializer</a> &amp;&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>assignedQueueIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates tuner for the specified compute API using custom initializer. The initializer contains user-provided compute device context and queues. The ids assigned to queues will be added to the provided vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>Compute API used by the tuner. </td></tr>
    <tr><td class="paramname">initializer</td><td>Custom compute API initializer. See <a class="el" href="classktt_1_1_compute_api_initializer.html">ComputeApiInitializer</a> for more information. </td></tr>
    <tr><td class="paramname">assignedQueueIds</td><td>Ids assigned to compute queues inside initializer by the tuner. The order of assigned ids matches the order of queues inside initializer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09198b07768176d263dbee8a6c54b377" name="a09198b07768176d263dbee8a6c54b377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09198b07768176d263dbee8a6c54b377">&#9670;&nbsp;</a></span>~Tuner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::~Tuner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classktt_1_1_tuner.html">Tuner</a> destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f1f558e170b15a155be9c7fac64d3a2" name="a7f1f558e170b15a155be9c7fac64d3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1f558e170b15a155be9c7fac64d3a2">&#9670;&nbsp;</a></span>AddArgumentLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentLocal </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>localMemorySize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new local memory (shared memory in CUDA) argument to the tuner. All local memory arguments are read-only and cannot be initialized from host memory. In case of CUDA API usage, local memory arguments cannot be directly set as kernel function arguments. Setting a local memory argument to kernel in CUDA means that corresponding amount of memory will be allocated for kernel to use. In that case, all local memory argument ids should be specified at the end of the vector when calling <a class="el" href="classktt_1_1_tuner.html#a1c2b24bebe7d9408c947c30f9471966d">SetArguments()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localMemorySize</td><td>Size of kernel argument in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a8aafe5e4d2e7d89fb1a59ad9069e3f88" name="a8aafe5e4d2e7d89fb1a59ad9069e3f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aafe5e4d2e7d89fb1a59ad9069e3f88">&#9670;&nbsp;</a></span>AddArgumentScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentScalar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new scalar argument to the tuner. All scalar arguments are read-only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Kernel argument data. The data type must be trivially copyable. Bool, reference or pointer types are not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a0014a51fff4d963f7eccba50ae4ecb28" name="a0014a51fff4d963f7eccba50ae4ecb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0014a51fff4d963f7eccba50ae4ecb28">&#9670;&nbsp;</a></span>AddArgumentScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentScalar </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new scalar argument to the tuner. All scalar arguments are read-only. This method can be utilized when templated version of scalar argument addition cannot be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to memory with kernel argument data. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size of data in bytes (e.g., 4 for 32-bit float). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="af45fabe98321bfe3f51bf5011897c69e" name="af45fabe98321bfe3f51bf5011897c69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45fabe98321bfe3f51bf5011897c69e">&#9670;&nbsp;</a></span>AddArgumentSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentSymbol </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbolName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new symbol argument to the tuner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Kernel argument data. The data type must be trivially copyable. Bool, reference or pointer types are not supported. </td></tr>
    <tr><td class="paramname">symbolName</td><td>Name of the corresponding symbol in kernel source code. Only utilized when tuner is using CUDA API. The symbol name must be unique. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="aa74cb565dee534d538c85d2d57a4b3f5" name="aa74cb565dee534d538c85d2d57a4b3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74cb565dee534d538c85d2d57a4b3f5">&#9670;&nbsp;</a></span>AddArgumentVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacektt.html#ab65fcc4157cfe64ccd1d00b177ccb5af">ComputeBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a>&#160;</td>
          <td class="paramname"><em>memoryLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new vector argument to the tuner. The argument buffer is created and managed by user and depending on the compute API, can be either CUdeviceptr or cl_mem handle. The tuner will not destroy the argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>User-provided memory buffer. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the provided user buffer in bytes. </td></tr>
    <tr><td class="paramname">accessType</td><td>Access type specifies whether argument is used for input or output. See <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> for more information. </td></tr>
    <tr><td class="paramname">memoryLocation</td><td>Memory location specifies whether argument data will be accessed from device or host memory during its usage by compute API. See <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a34b8bb17df50309173a07303fb1b10a7" name="a34b8bb17df50309173a07303fb1b10a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b8bb17df50309173a07303fb1b10a7">&#9670;&nbsp;</a></span>AddArgumentVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacektt.html#ab65fcc4157cfe64ccd1d00b177ccb5af">ComputeBuffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a>&#160;</td>
          <td class="paramname"><em>memoryLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new vector argument to the tuner. The argument buffer is created and managed by user and depending on the compute API, can be either CUdeviceptr or cl_mem handle. The tuner will not destroy the argument. This method can be utilized when templated version of argument addition cannot be used. When using validation for arguments added through this method, value comparator must always be provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>User-provided memory buffer. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the provided user buffer in bytes. </td></tr>
    <tr><td class="paramname">elementSize</td><td>Size of a single element inside buffer in bytes (e.g., 4 for 32-bit float). </td></tr>
    <tr><td class="paramname">accessType</td><td>Access type specifies whether argument is used for input or output. See <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> for more information. </td></tr>
    <tr><td class="paramname">memoryLocation</td><td>Memory location specifies whether argument data will be accessed from device or host memory during its usage by compute API. See <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a4a8fdad5788a9f1c6bb71b731c17d89c" name="a4a8fdad5788a9f1c6bb71b731c17d89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8fdad5788a9f1c6bb71b731c17d89c">&#9670;&nbsp;</a></span>AddArgumentVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new vector argument to the tuner. Makes copy of argument data, so the source data vector remains unaffected by tuner operations. Argument data will be accessed from device memory during its usage by compute API. The compute API buffer will be automatically created and managed by the KTT framework. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Kernel argument data. The data type must be trivially copyable. Bool, reference or pointer types are not supported. </td></tr>
    <tr><td class="paramname">accessType</td><td>Access type specifies whether argument is used for input or output. See <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a2b3b932d8a87ff1e2a20b1c791af38dc" name="a2b3b932d8a87ff1e2a20b1c791af38dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3b932d8a87ff1e2a20b1c791af38dc">&#9670;&nbsp;</a></span>AddArgumentVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::AddArgumentVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a>&#160;</td>
          <td class="paramname"><em>memoryLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a6c3eb24a8cdc991dd7b7274cc340852f">ArgumentManagementType</a>&#160;</td>
          <td class="paramname"><em>managementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>referenceUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new vector argument to the tuner. Allows wide range of argument customization options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Kernel argument data. The data type must be trivially copyable. Bool, reference or pointer types are not supported. </td></tr>
    <tr><td class="paramname">accessType</td><td>Access type specifies whether argument is used for input or output. See <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> for more information. </td></tr>
    <tr><td class="paramname">memoryLocation</td><td>Memory location specifies whether argument data will be accessed from device or host memory during its usage by compute API. See <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> for more information. </td></tr>
    <tr><td class="paramname">managementType</td><td>Management type specifies who is responsible for creating, managing data and destroying compute API buffer corresponding to the argument. See <a class="el" href="namespacektt.html#a6c3eb24a8cdc991dd7b7274cc340852f">ArgumentManagementType</a> for more information. </td></tr>
    <tr><td class="paramname">referenceUserData</td><td>If set to true, tuner will store reference to source data and will access it directly during buffer operations. This results in lower memory overhead, but relies on a user to keep data in the source vector valid. If set to false, copy of the data will be made by the tuner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a9894503f98831c5c3f391c5bb5729ed4" name="a9894503f98831c5c3f391c5bb5729ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9894503f98831c5c3f391c5bb5729ed4">&#9670;&nbsp;</a></span>AddComputeQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> ktt::Tuner::AddComputeQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a9a45ee3a893226dc9802b5cae9e6dff5">ComputeQueue</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds the specified compute queue to the tuner. New queues can only be added if tuner was initialized with compute API initializer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue which will be added. The queue should be tied to the context specified inside compute API initializer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to queue by the tuner. </dd></dl>

</div>
</div>
<a id="a5cfc141a0f3d3dbb237a76c394d760b8" name="a5cfc141a0f3d3dbb237a76c394d760b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfc141a0f3d3dbb237a76c394d760b8">&#9670;&nbsp;</a></span>AddConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a60f871f057714181e6e88faf66d838b3">ConstraintFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds constraint for the specified kernel. Constraints are used to prevent generating of configurations with conflicting combinations of parameter values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the constraint will be added. </td></tr>
    <tr><td class="paramname">parameters</td><td>Names of kernel parameters which will be affected by the constraint function. The order of parameter names corresponds to the order of parameter values inside the constraint function vector argument. Note that constraints can only be added between parameters which belong into the same group. The corresponding parameters must be added to the tuner with <a class="el" href="classktt_1_1_tuner.html#aaf79f9092d20f151b7d9690ffbdfc8ff">AddParameter()</a> before calling this method. </td></tr>
    <tr><td class="paramname">function</td><td>Function which returns true if the provided combination of parameter values is valid. Returns false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d47480e40733abfad1780f599a4be8" name="a98d47480e40733abfad1780f599a4be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d47480e40733abfad1780f599a4be8">&#9670;&nbsp;</a></span>AddKernelDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> ktt::Tuner::AddKernelDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>typeNames</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new kernel definition to the tuner. Requires specification of a kernel name, its source code and default global and local thread sizes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of a kernel function inside kernel source code. The name must be unique. </td></tr>
    <tr><td class="paramname">source</td><td>Kernel source code written in the corresponding compute API language. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for base kernel global size (e.g., grid size in CUDA, NDRange size in OpenCL). </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for base kernel local size (e.g., block size in CUDA, work-group size in OpenCL). </td></tr>
    <tr><td class="paramname">typeNames</td><td>Names of types which will be used to instantiate kernel template. Only supported in CUDA kernels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel definition by the tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="ad3c8e80a4eefa9dd00b475b237a40e9b" name="ad3c8e80a4eefa9dd00b475b237a40e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c8e80a4eefa9dd00b475b237a40e9b">&#9670;&nbsp;</a></span>AddKernelDefinitionFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> ktt::Tuner::AddKernelDefinitionFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>typeNames</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new kernel definition to the tuner. Requires specification of a kernel name, file path to its source code and default global and local thread sizes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of a kernel function inside kernel source code. The name must be unique. </td></tr>
    <tr><td class="paramname">filePath</td><td>Path to file with kernel source code written in the corresponding compute API language. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for base kernel global size (e.g., grid size in CUDA, NDRange size in OpenCL). </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for base kernel local size (e.g., block size in CUDA, work-group size in OpenCL). </td></tr>
    <tr><td class="paramname">typeNames</td><td>Names of types which will be used to instantiate kernel template. Only supported in CUDA kernels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel definition by the tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a805fb0026bbd0e2787b75ea058d1f10f" name="a805fb0026bbd0e2787b75ea058d1f10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805fb0026bbd0e2787b75ea058d1f10f">&#9670;&nbsp;</a></span>AddParameter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::AddParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new floating-point parameter for the specified kernel, providing parameter name and list of allowed values. Parameters will be added to the kernel source code as preprocessor definitions. During the tuning process, tuner will generate configurations for combinations of kernel parameters and their values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the parameter will be added. </td></tr>
    <tr><td class="paramname">name</td><td>Name of a parameter. Parameter names for a single kernel must be unique. </td></tr>
    <tr><td class="paramname">values</td><td>Allowed values for the parameter. </td></tr>
    <tr><td class="paramname">group</td><td>Optional group inside which the parameter will be added. Tuning configurations are generated separately for each group. This is useful when kernels contain groups of parameters that can be tuned independently. In this way, the total number of generated configurations can be significantly reduced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf79f9092d20f151b7d9690ffbdfc8ff" name="aaf79f9092d20f151b7d9690ffbdfc8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf79f9092d20f151b7d9690ffbdfc8ff">&#9670;&nbsp;</a></span>AddParameter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::AddParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds new integer parameter for the specified kernel, providing parameter name and list of allowed values. Parameters will be added to the kernel source code as preprocessor definitions. During the tuning process, tuner will generate configurations for combinations of kernel parameters and their values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the parameter will be added. </td></tr>
    <tr><td class="paramname">name</td><td>Name of a parameter. Parameter names for a single kernel must be unique. </td></tr>
    <tr><td class="paramname">values</td><td>Allowed values for the parameter. </td></tr>
    <tr><td class="paramname">group</td><td>Optional group inside which the parameter will be added. Tuning configurations are generated separately for each group. This is useful when kernels contain groups of parameters that can be tuned independently. In this way, the total number of generated configurations can be significantly reduced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa34ed21ac3bdfd2421f7ba0abe62aa7b" name="aa34ed21ac3bdfd2421f7ba0abe62aa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34ed21ac3bdfd2421f7ba0abe62aa7b">&#9670;&nbsp;</a></span>AddThreadModifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::AddThreadModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>definitionIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a>&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds thread modifier function for the specified kernel. This is a simplified version of the thread modifier method which supports only a single kernel parameter and limited number of actions, but is easier to use. If multiple thread modifiers are specified for the same type and dimension, they are applied in order of their addition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the modifier will be set. </td></tr>
    <tr><td class="paramname">definitionIds</td><td>Kernel definitions whose thread sizes will be affected by the thread modifier. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the thread modifier. See <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> for more information. </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension which will be affected by the thread modifier. See <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> for more information. </td></tr>
    <tr><td class="paramname">parameter</td><td>Name of a kernel parameter whose value will be utilized by the thread modifier. The corresponding parameter must be added to the tuner with <a class="el" href="classktt_1_1_tuner.html#aaf79f9092d20f151b7d9690ffbdfc8ff">AddParameter()</a> before calling this method. </td></tr>
    <tr><td class="paramname">action</td><td>Action of the thread modifier. See <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfaa5b962d4742ff4aa70171a990a3dd" name="adfaa5b962d4742ff4aa70171a990a3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaa5b962d4742ff4aa70171a990a3dd">&#9670;&nbsp;</a></span>AddThreadModifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::AddThreadModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>definitionIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a>&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#ad8b6453e21ff3d1bf4208886d9af8810">ModifierFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds thread modifier function for the specified kernel. The function receives thread size in the specified dimension and values of the specified kernel parameters as input and returns modified thread size based on these values. Thread modifiers are useful in cases when kernel parameters affect number of required kernel threads. If multiple thread modifiers are specified for the same type and dimension, they are applied in order of their addition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the modifier will be set. </td></tr>
    <tr><td class="paramname">definitionIds</td><td>Kernel definitions whose thread sizes will be affected by the thread modifier. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the thread modifier. See <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> for more information. </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension which will be affected by the modifier. See <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> for more information. </td></tr>
    <tr><td class="paramname">parameters</td><td>Names of kernel parameters whose values will be passed into the modifier function. The order of parameter names will correspond to the order of parameter values inside the modifier function vector argument. The corresponding parameters must be added to the tuner with <a class="el" href="classktt_1_1_tuner.html#aaf79f9092d20f151b7d9690ffbdfc8ff">AddParameter()</a> before calling this method. </td></tr>
    <tr><td class="paramname">function</td><td>Function which receives thread size in the specified kernel dimension and values of kernel parameters as input and returns modified thread size based on these values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa87f966ad499bd35c2c7526574a7ed34" name="aa87f966ad499bd35c2c7526574a7ed34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87f966ad499bd35c2c7526574a7ed34">&#9670;&nbsp;</a></span>ClearData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::ClearData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resets tuning process and clears generated configurations for the specified kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel whose data will be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a99601a2d8876cecb6a5455a55e8c1e" name="a1a99601a2d8876cecb6a5455a55e8c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a99601a2d8876cecb6a5455a55e8c1e">&#9670;&nbsp;</a></span>CreateCompositeKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> ktt::Tuner::CreateCompositeKernel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>definitionIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#afd0d71d6fa61d6a1660bf233ae1df2ac">KernelLauncher</a>&#160;</td>
          <td class="paramname"><em>launcher</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates composite kernel from the specified definitions. Note that kernel launcher is required in order to launch kernels with multiple definitions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Kernel name used during logging and output operations. The name must be unique. </td></tr>
    <tr><td class="paramname">definitionIds</td><td>Ids of kernel definitions which will be utilized by the kernel. </td></tr>
    <tr><td class="paramname">launcher</td><td>Launcher for the kernel. It can be defined either during kernel creation or later with <a class="el" href="classktt_1_1_tuner.html#af17f07f5fa61fcfcd9dbe77068209992">SetLauncher()</a> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel by the tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a888c5696b3aac3ff9892df7ebbb7022e" name="a888c5696b3aac3ff9892df7ebbb7022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888c5696b3aac3ff9892df7ebbb7022e">&#9670;&nbsp;</a></span>CreateConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> ktt::Tuner::CreateConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aef951ec46e383694c8512ddaa6b200d6">ParameterInput</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates and returns configuration for the specified kernel based on provided parameters and their values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the configuration will be created. </td></tr>
    <tr><td class="paramname">parameters</td><td>Vector of parameter names and their values from which the configuration is generated. If certain parameters are omitted, their first specified values are added to the configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configuration created based on the specified input. See <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> for more information. </dd></dl>

</div>
</div>
<a id="a136a3e45466bc0434484b06ae338c3cc" name="a136a3e45466bc0434484b06ae338c3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136a3e45466bc0434484b06ae338c3cc">&#9670;&nbsp;</a></span>CreateSimpleKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> ktt::Tuner::CreateSimpleKernel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>definitionId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates simple kernel from the specified definition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Kernel name used during logging and output operations. The name must be unique. </td></tr>
    <tr><td class="paramname">definitionId</td><td>Id of kernel definition which will be utilized by the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel by the tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a360361884d6c490d557d9926da3b813d" name="a360361884d6c490d557d9926da3b813d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360361884d6c490d557d9926da3b813d">&#9670;&nbsp;</a></span>GetBestConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> ktt::Tuner::GetBestConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the best configuration found for specified kernel. Valid configuration will be returned only if kernel tuning was already performed for the corresponding kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the best configuration will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best configuration for the specified kernel. See <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> for more information. </dd></dl>

</div>
</div>
<a id="a3a08f0fef2d05fd93913f6a461c8d77a" name="a3a08f0fef2d05fd93913f6a461c8d77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a08f0fef2d05fd93913f6a461c8d77a">&#9670;&nbsp;</a></span>GetCurrentDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> ktt::Tuner::GetCurrentDeviceInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves detailed information about device used by the tuner. See <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> for more information. </p><dl class="section return"><dt>Returns</dt><dd>Information about device used by the tuner. </dd></dl>

</div>
</div>
<a id="a4bc8f3f6cca5a25c91a26a78d1581e3f" name="a4bc8f3f6cca5a25c91a26a78d1581e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8f3f6cca5a25c91a26a78d1581e3f">&#9670;&nbsp;</a></span>GetDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> &gt; ktt::Tuner::GetDeviceInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves detailed information about all available devices on the specified platform. See <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index of platform for which the device information will be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about all available devices on the specified platform. </dd></dl>

</div>
</div>
<a id="a9db4f79c0e1d7cc2e2eb3e194e6a0cb8" name="a9db4f79c0e1d7cc2e2eb3e194e6a0cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db4f79c0e1d7cc2e2eb3e194e6a0cb8">&#9670;&nbsp;</a></span>GetKernelDefinitionId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> ktt::Tuner::GetKernelDefinitionId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>typeNames</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves kernel definition id from the tuner based on provided name and template arguments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of a kernel definition. </td></tr>
    <tr><td class="paramname">typeNames</td><td>Names of types which were used to instantiate kernel template. Only supported in CUDA kernels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the corresponding kernel definition. If no such definition exists, InvalidKernelDefinitionId will be returned. </dd></dl>

</div>
</div>
<a id="a226f0185c96bcc8f54b1b9deb9d6b4d8" name="a226f0185c96bcc8f54b1b9deb9d6b4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f0185c96bcc8f54b1b9deb9d6b4d8">&#9670;&nbsp;</a></span>GetKernelDefinitionSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ktt::Tuner::GetKernelDefinitionSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns kernel source with preprocessor definitions for the specified kernel definition based on provided configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition for which the source is returned. </td></tr>
    <tr><td class="paramname">configuration</td><td>Kernel configuration for which the source will be generated. See <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kernel definition source with preprocessor definitions for the specified kernel based on provided configuration. </dd></dl>

</div>
</div>
<a id="afa014f51574f99a828f040895290f3f4" name="afa014f51574f99a828f040895290f3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa014f51574f99a828f040895290f3f4">&#9670;&nbsp;</a></span>GetKernelSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ktt::Tuner::GetKernelSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns kernel source with preprocessor definitions for the specified kernel based on provided configuration. Valid source is returned only for kernels with single definition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the source is returned. </td></tr>
    <tr><td class="paramname">configuration</td><td>Kernel configuration for which the source will be generated. See <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kernel source with preprocessor definitions for the specified kernel based on provided configuration. </dd></dl>

</div>
</div>
<a id="a5c02e27e4f5631fa2b45d6ed9f7edea1" name="a5c02e27e4f5631fa2b45d6ed9f7edea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c02e27e4f5631fa2b45d6ed9f7edea1">&#9670;&nbsp;</a></span>GetPlatformInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_platform_info.html">PlatformInfo</a> &gt; ktt::Tuner::GetPlatformInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves detailed information about all available platforms. See <a class="el" href="classktt_1_1_platform_info.html">PlatformInfo</a> for more information. </p><dl class="section return"><dt>Returns</dt><dd>Information about all available platforms. </dd></dl>

</div>
</div>
<a id="a5870dcea68c8006b1ca92c90171018b4" name="a5870dcea68c8006b1ca92c90171018b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5870dcea68c8006b1ca92c90171018b4">&#9670;&nbsp;</a></span>LoadResults() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; ktt::Tuner::LoadResults </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Loads kernel results from the specified file. The file must be previously created by the tuner method <a class="el" href="classktt_1_1_tuner.html#a5ac6711abae75fff387e8083af75dc79">SaveResults()</a> with corresponding output format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>File from which the results will be loaded. The file extension is added automatically based on the specified format. </td></tr>
    <tr><td class="paramname">format</td><td>Format in which the results are stored. See <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results loaded from the file. </dd></dl>

</div>
</div>
<a id="a0e2675eb66dd12edc676df06e4a6db5a" name="a0e2675eb66dd12edc676df06e4a6db5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2675eb66dd12edc676df06e4a6db5a">&#9670;&nbsp;</a></span>LoadResults() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; ktt::Tuner::LoadResults </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#af9cd5c78192f75cafc2a66b8942868bb">UserData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Loads kernel results from the specified file. The file must be previously created by the tuner method <a class="el" href="classktt_1_1_tuner.html#a5ac6711abae75fff387e8083af75dc79">SaveResults()</a> with corresponding output format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>File from which the results will be loaded. The file extension is added automatically based on the specified format. </td></tr>
    <tr><td class="paramname">format</td><td>Format in which the results are stored. See <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a> for more information. </td></tr>
    <tr><td class="paramname">data</td><td>User data which will be loaded from the file together with results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results loaded from the file. </dd></dl>

</div>
</div>
<a id="a9243c05712e47d182385b2e097403ea5" name="a9243c05712e47d182385b2e097403ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9243c05712e47d182385b2e097403ea5">&#9670;&nbsp;</a></span>RemoveArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::RemoveArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes argument with the specified id from the tuner. Note that argument can only be removed if it is not associated with any kernel definition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the argument which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2016ef58ab7ade647bf93fa43808c78e" name="a2016ef58ab7ade647bf93fa43808c78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2016ef58ab7ade647bf93fa43808c78e">&#9670;&nbsp;</a></span>RemoveComputeQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::RemoveComputeQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the specified compute queue from the tuner. Only queues added by user can be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of compute queue which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f62e176f33adafdde70dd077fb9e88" name="a95f62e176f33adafdde70dd077fb9e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f62e176f33adafdde70dd077fb9e88">&#9670;&nbsp;</a></span>RemoveKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::RemoveKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes kernel with the specified id from the tuner. If the kernel is used as a reference kernel, the corresponding kernel argument output validation will be disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the kernel which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a789c4c550bd615bda43afd152d410b6c" name="a789c4c550bd615bda43afd152d410b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789c4c550bd615bda43afd152d410b6c">&#9670;&nbsp;</a></span>RemoveKernelDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::RemoveKernelDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes kernel definition with the specified id from the tuner. Note that definition can only be removed if it is not associated with any kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the kernel definition which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78ced5f956d194f95d1eab209c0da355" name="a78ced5f956d194f95d1eab209c0da355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ced5f956d194f95d1eab209c0da355">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> ktt::Tuner::Run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_buffer_output_descriptor.html">BufferOutputDescriptor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runs kernel using the specified configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. </td></tr>
    <tr><td class="paramname">configuration</td><td>Configuration under which the kernel will be launched. See <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> for more information. </td></tr>
    <tr><td class="paramname">output</td><td>User-provided memory locations for kernel arguments which should be retrieved. See <a class="el" href="classktt_1_1_buffer_output_descriptor.html">BufferOutputDescriptor</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result containing information about kernel computation. See <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> for more information. </dd></dl>

</div>
</div>
<a id="a5ac6711abae75fff387e8083af75dc79" name="a5ac6711abae75fff387e8083af75dc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac6711abae75fff387e8083af75dc79">&#9670;&nbsp;</a></span>SaveResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SaveResults </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af9cd5c78192f75cafc2a66b8942868bb">UserData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Saves specified kernel results to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>Results which will be saved. </td></tr>
    <tr><td class="paramname">filePath</td><td>File where the results will be saved. The file extension is added automatically based on the specified format. </td></tr>
    <tr><td class="paramname">format</td><td>Format in which the results are saved. See <a class="el" href="namespacektt.html#aa3395e2ad389eb11a09e94a5eb5e5b51">OutputFormat</a> for more information. </td></tr>
    <tr><td class="paramname">data</td><td>User data which will be saved into the file together with results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c2b24bebe7d9408c947c30f9471966d" name="a1c2b24bebe7d9408c947c30f9471966d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2b24bebe7d9408c947c30f9471966d">&#9670;&nbsp;</a></span>SetArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argumentIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets arguments for the specified kernel definition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of a kernel definition for which the arguments will be set. </td></tr>
    <tr><td class="paramname">argumentIds</td><td>Ids of arguments to be used by the specified definition. The order of ids must match the order of kernel arguments inside kernel function. The provided ids must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e95025e0f39526e756a947e953afd9a" name="a7e95025e0f39526e756a947e953afd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95025e0f39526e756a947e953afd9a">&#9670;&nbsp;</a></span>SetAutomaticGlobalSizeCorrection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetAutomaticGlobalSizeCorrection </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Toggles automatic correction for kernel global size, which ensures that global size in each dimension is always a multiple of local size in corresponding dimension. Performs a roundup to the nearest higher multiple. Automatic global size correction is disabled by default. Note that automatic global size correction works only if global size type is set to OpenCL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If true, automatic global size correction will be enabled. It will be disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cce9a3ee4f44f2e7dbd4e01fc4d9d4b" name="a6cce9a3ee4f44f2e7dbd4e01fc4d9d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cce9a3ee4f44f2e7dbd4e01fc4d9d4b">&#9670;&nbsp;</a></span>SetCompilerOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetCompilerOptions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets compute API compiler options to specified options. There are no default options for OpenCL backend. By default for CUDA backend it adds the compiler option "--gpu-architecture=compute_xx", where <code>xx</code> is the compute capability retrieved from the device. For the list of OpenCL compiler options, see: <a href="https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clBuildProgram.html">https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clBuildProgram.html</a> For the list of CUDA compiler options, see: <a href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#nvcc-command-options">http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#nvcc-command-options</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Compute API compiler options. If multiple options are used, they need to be separated by a single space character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd1c985b64a88a2b66835c4afa9fdc8f" name="abd1c985b64a88a2b66835c4afa9fdc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1c985b64a88a2b66835c4afa9fdc8f">&#9670;&nbsp;</a></span>SetGlobalSizeType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetGlobalSizeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a16e643cd2325370c79affaeee8ef85f0">GlobalSizeType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets global size specification type to specified compute API style. In OpenCL, NDrange size is specified as number of work-items in a work-group multiplied by number of work-groups. In CUDA, grid size is specified as number of blocks. This method makes it possible to use OpenCL style in CUDA and vice versa. Default global size type is the one corresponding to the compute API used by the tuner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Global size type which will be set for tuner. See <a class="el" href="namespacektt.html#a16e643cd2325370c79affaeee8ef85f0">GlobalSizeType</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a018e398312c674b8aca5e7fbfa128871" name="a018e398312c674b8aca5e7fbfa128871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018e398312c674b8aca5e7fbfa128871">&#9670;&nbsp;</a></span>SetKernelCacheCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetKernelCacheCapacity </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets capacity of compiled kernel cache used by the tuner. The cache contains recently compiled kernels which are prepared to be launched immediately, eliminating compilation overhead. Using the cache can significantly improve tuner performance during online tuning or iterative kernel running with custom KernelLauncher. Default cache size is 10. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Controls kernel cache capacity. If zero, kernel cache is completely disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af17f07f5fa61fcfcd9dbe77068209992" name="af17f07f5fa61fcfcd9dbe77068209992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17f07f5fa61fcfcd9dbe77068209992">&#9670;&nbsp;</a></span>SetLauncher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetLauncher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#afd0d71d6fa61d6a1660bf233ae1df2ac">KernelLauncher</a>&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specifies kernel launcher for a kernel. Kernel launcher enables customization of kernel execution. This is useful in multiple cases. E.g., running part of the computation in C++ code, utilizing iterative kernel launches or kernels with multiple definitions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which launcher will be set. </td></tr>
    <tr><td class="paramname">launcher</td><td>Launcher for the specified kernel. See <a class="el" href="classktt_1_1_compute_interface.html">ComputeInterface</a> for further information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8503c25c10dc31b9e15e56d7a597856d" name="a8503c25c10dc31b9e15e56d7a597856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8503c25c10dc31b9e15e56d7a597856d">&#9670;&nbsp;</a></span>SetLoggingLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::SetLoggingLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a17afdb449e82292a32fba46ff7a54781">LoggingLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets logging level for tuner. Default logging level is info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Logging level which will be used by tuner. See <a class="el" href="namespacektt.html#a17afdb449e82292a32fba46ff7a54781">LoggingLevel</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af135d787110cbbc19bc66def1b705b4e" name="af135d787110cbbc19bc66def1b705b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af135d787110cbbc19bc66def1b705b4e">&#9670;&nbsp;</a></span>SetLoggingTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::SetLoggingTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the target for info messages logging to specified file. Default logging target is <code>std::clog</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to file where tuner info messages will printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab89be1d46163994257094765fc398fac" name="ab89be1d46163994257094765fc398fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89be1d46163994257094765fc398fac">&#9670;&nbsp;</a></span>SetLoggingTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::SetLoggingTarget </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outputTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the target for info messages logging to specified output stream. Default logging target is <code>std::clog</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputTarget</td><td>Location where tuner info messages will be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9ed472e7c2bd1b01799bf37802c796" name="a6d9ed472e7c2bd1b01799bf37802c796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9ed472e7c2bd1b01799bf37802c796">&#9670;&nbsp;</a></span>SetProfiledDefinitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetProfiledDefinitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>definitionIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enables profiling of specified kernel definitions. This is useful if only some definitions inside the kernel need to be profiled. By default, profiling is enabled only for the first definition specified during kernel creation. Note that this method has effect only if kernel profiling functionality is enabled. See SetKernelProfiling() method for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the profiled definitions will be set. </td></tr>
    <tr><td class="paramname">definitionIds</td><td>Ids of definitions inside the kernel for which the profiling will be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a005ffd8e117b1f6f6a564bdbe53e33ca" name="a005ffd8e117b1f6f6a564bdbe53e33ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005ffd8e117b1f6f6a564bdbe53e33ca">&#9670;&nbsp;</a></span>SetProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetProfiling </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Toggles profiling of kernels inside the tuner. Profiled kernel runs generate profiling counters which can be used by searchers and stop conditions for more accurate performance measurement. Profiling counters can also be retrieved through API and saved into a file with kernel results. Note that enabling profiling will result in longer tuning times because profiled kernels have to be launched multiple times with the same configuration in order to collect all profiling counters. Asynchronous kernel launches are not supported when kernel profiling is enabled. Kernel profiling is disabled by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If true, kernel profiling is enabled. It is disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a9ca12b75ea217b0a7f9f68e28639a" name="ab5a9ca12b75ea217b0a7f9f68e28639a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a9ca12b75ea217b0a7f9f68e28639a">&#9670;&nbsp;</a></span>SetProfilingCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetProfilingCounters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>counters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specifies profiling counters that will be collected during kernel profiling. Note that not all profiling counters are available on all devices. For the list of old CUDA CUPTI profiling counters, see: <a href="https://docs.nvidia.com/cupti/Cupti/r_main.html#metrics-reference">https://docs.nvidia.com/cupti/Cupti/r_main.html#metrics-reference</a> For the list of new CUDA CUPTI profiling counters, see: <a href="https://docs.nvidia.com/cupti/Cupti/r_main.html#r_host_raw_metrics_api">https://docs.nvidia.com/cupti/Cupti/r_main.html#r_host_raw_metrics_api</a> For the list of AMD GPA profiling counters, see: <a href="https://gpuperfapi.readthedocs.io/en/latest/counters.html">https://gpuperfapi.readthedocs.io/en/latest/counters.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counters</td><td>Names of counters that will be collected during kernel profiling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab906111fbc44d2a7be1afad5c9b131a1" name="ab906111fbc44d2a7be1afad5c9b131a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab906111fbc44d2a7be1afad5c9b131a1">&#9670;&nbsp;</a></span>SetReadOnlyArgumentCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetReadOnlyArgumentCache </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Toggles caching of read-only kernel arguments which have management type set to framework. This can significantly speed up tuning, since arguments are uploaded into compute API buffers only once. Caching is enabled by default. Users who wish to modify read-only arguments inside kernel launcher may want to disable this behaviour. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If true, read-only argument caching is enabled. It is disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a966c08e5ca21c2731288a7b2eb3b1229" name="a966c08e5ca21c2731288a7b2eb3b1229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966c08e5ca21c2731288a7b2eb3b1229">&#9670;&nbsp;</a></span>SetReferenceComputation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetReferenceComputation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#aa072e8ed2d94052fbb5686b3ff75878f">ReferenceComputation</a>&#160;</td>
          <td class="paramname"><em>computation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets reference computation for the specified argument. Reference computation output will be compared to tuned kernel output in order to ensure correctness of computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which reference computation will be set. Only not read-only vector arguments can be validated. </td></tr>
    <tr><td class="paramname">computation</td><td>Function which receives memory buffer on input where it stores its computed reference result. The size of buffer matches the size of kernel argument in bytes. If a custom validation range was set, the size of buffer matches the specified range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1044c7e763c75254ddb25ba53a749dd9" name="a1044c7e763c75254ddb25ba53a749dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1044c7e763c75254ddb25ba53a749dd9">&#9670;&nbsp;</a></span>SetReferenceKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetReferenceKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>referenceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets reference kernel for the specified argument. Reference kernel output will be compared to tuned kernel output in order to ensure correctness of computation. Reference kernel uses only specified configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which reference kernel will be set. Only not read-only vector arguments can be validated. </td></tr>
    <tr><td class="paramname">referenceId</td><td>Id of reference kernel. </td></tr>
    <tr><td class="paramname">configuration</td><td>Configuration under which the reference kernel will be launched to produce reference output. This is useful if the kernel has a configuration which is known to produce correct results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaff564535e11125821fb39b1bd863fdb" name="aaff564535e11125821fb39b1bd863fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff564535e11125821fb39b1bd863fdb">&#9670;&nbsp;</a></span>SetSearcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classktt_1_1_searcher.html">Searcher</a> &gt;&#160;</td>
          <td class="paramname"><em>searcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets searcher which will be used during kernel tuning. If no searcher is specified, <a class="el" href="classktt_1_1_deterministic_searcher.html">DeterministicSearcher</a> will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which searcher will be set. </td></tr>
    <tr><td class="paramname">searcher</td><td><a class="el" href="classktt_1_1_searcher.html">Searcher</a> which decides which kernel configuration will be launched next. See <a class="el" href="classktt_1_1_searcher.html">Searcher</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b9a2ebdc68c3edc6c9102354f2dcd8" name="a65b9a2ebdc68c3edc6c9102354f2dcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b9a2ebdc68c3edc6c9102354f2dcd8">&#9670;&nbsp;</a></span>SetTimeUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::SetTimeUnit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a161b9af8714615ef2c1770b020ce1511">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets time unit used for printing of results. Default time unit is milliseconds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>Time unit which will be used for printing of results. See <a class="el" href="namespacektt.html#a161b9af8714615ef2c1770b020ce1511">TimeUnit</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ddedf54b28a454e347f0d40d4c57185" name="a0ddedf54b28a454e347f0d40d4c57185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddedf54b28a454e347f0d40d4c57185">&#9670;&nbsp;</a></span>SetValidationMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetValidationMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a187d4987bb48bc1f78f628c8aa840a20">ValidationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>toleranceThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets validation method and tolerance threshold for floating-point argument validation. Default validation method is side by side comparison. Default tolerance threshold is 1e-4. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Validation method which will be used for floating-point argument validation. See <a class="el" href="namespacektt.html#a187d4987bb48bc1f78f628c8aa840a20">ValidationMethod</a> for more information. </td></tr>
    <tr><td class="paramname">toleranceThreshold</td><td>Output validation threshold. If difference between tuned kernel output and reference output is within the threshold, the tuned kernel output will be considered correct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77e12637ab4df58139ce03161f6a9a47" name="a77e12637ab4df58139ce03161f6a9a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e12637ab4df58139ce03161f6a9a47">&#9670;&nbsp;</a></span>SetValidationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetValidationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a3baf318a03750f7418a5faa051967c04">ValidationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets mode under which kernel output validation is enabled. By default, output validation is enabled only during kernel tuning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Bitfield of modes under which kernel output validation is enabled. See <a class="el" href="namespacektt.html#a3baf318a03750f7418a5faa051967c04">ValidationMode</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d0a53f0d54ac5a285b40386ec5a39a4" name="a8d0a53f0d54ac5a285b40386ec5a39a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0a53f0d54ac5a285b40386ec5a39a4">&#9670;&nbsp;</a></span>SetValidationRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetValidationRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets validation range for the specified argument. The entire argument is validated by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the validation range will be set. Only not read-only vector arguments can be validated. </td></tr>
    <tr><td class="paramname">range</td><td>Number of argument elements which will be validated, starting from the first element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385b67cfa5ac085f540fe21c1f461bf2" name="a385b67cfa5ac085f540fe21c1f461bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385b67cfa5ac085f540fe21c1f461bf2">&#9670;&nbsp;</a></span>SetValueComparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SetValueComparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#ab2cf30aab952f8ea4366979237f9e1e9">ValueComparator</a>&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets value comparator for the specified kernel argument. Arguments with custom data type cannot be compared using built-in comparison operators and require user to provide a comparator. Comparator can also be optionally added for arguments with built-in data types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the comparator will be set. Only not read-only vector arguments can be validated. </td></tr>
    <tr><td class="paramname">comparator</td><td>Function which receives two elements with data type matching the type of specified kernel argument and returns true if the elements are equal. Returns false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf0bb2189bf6c1210c42b0f1ddd93399" name="acf0bb2189bf6c1210c42b0f1ddd93399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0bb2189bf6c1210c42b0f1ddd93399">&#9670;&nbsp;</a></span>SimulateKernelTuning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; ktt::Tuner::SimulateKernelTuning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs simulated tuning process for the specified kernel. The kernel is not tuned, execution times are read from the provided results. Creates configuration space based on combinations of provided kernel parameters and constraints. The configurations will be launched in order that depends on specified <a class="el" href="classktt_1_1_searcher.html">Searcher</a>. This method can be used to test behaviour and performance of newly implemented searchers. The provided results should correspond to the results output by the same kernel during regular tuning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the kernel for simulated tuning. </td></tr>
    <tr><td class="paramname">results</td><td>Results from which the kernel execution times will be retrieved. </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of iterations performed. If equal to 0, search of the entire tuning space is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of results for configurations chosen by the searcher during simulated tuning. </dd></dl>

</div>
</div>
<a id="a0c8667aa5703517c100b261a23eed0dd" name="a0c8667aa5703517c100b261a23eed0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8667aa5703517c100b261a23eed0dd">&#9670;&nbsp;</a></span>Synchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::Synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Blocks until all commands submitted to KTT device are completed. </p>

</div>
</div>
<a id="aa38e76c15db1d25743288ebccd67df3b" name="aa38e76c15db1d25743288ebccd67df3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38e76c15db1d25743288ebccd67df3b">&#9670;&nbsp;</a></span>SynchronizeDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SynchronizeDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Blocks until all commands submitted to KTT device are completed. </p>

</div>
</div>
<a id="a9f056f4076db595826eea1bdbacbcdcb" name="a9f056f4076db595826eea1bdbacbcdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f056f4076db595826eea1bdbacbcdcb">&#9670;&nbsp;</a></span>SynchronizeQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SynchronizeQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Blocks until all commands submitted to the specified KTT device queue are completed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of queue which will be synchronized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1cc2c4aac72510f028ada44a0283fab" name="ad1cc2c4aac72510f028ada44a0283fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cc2c4aac72510f028ada44a0283fab">&#9670;&nbsp;</a></span>SynchronizeQueues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::SynchronizeQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Blocks until all commands submitted to all KTT device queues are completed. </p>

</div>
</div>
<a id="a7ed0d38ea099aef96218bd95a98e8a06" name="a7ed0d38ea099aef96218bd95a98e8a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed0d38ea099aef96218bd95a98e8a06">&#9670;&nbsp;</a></span>Tune() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; ktt::Tuner::Tune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs the tuning process for specified kernel. Creates configuration space based on combinations of provided kernel parameters and constraints. The configurations will be launched in order that depends on the specified <a class="el" href="classktt_1_1_searcher.html">Searcher</a>. Tuning will end when all configurations are explored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the tuned kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of results containing information about kernel computation in specific configuration. See <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> for more information. </dd></dl>

</div>
</div>
<a id="a16040c3a6f5603ef337ef4a7057f9b69" name="a16040c3a6f5603ef337ef4a7057f9b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16040c3a6f5603ef337ef4a7057f9b69">&#9670;&nbsp;</a></span>Tune() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> &gt; ktt::Tuner::Tune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classktt_1_1_stop_condition.html">StopCondition</a> &gt;&#160;</td>
          <td class="paramname"><em>stopCondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs the tuning process for specified kernel. Creates configuration space based on combinations of provided kernel parameters and constraints. The configurations will be launched in order that depends on the specified <a class="el" href="classktt_1_1_searcher.html">Searcher</a>. Tuning will end either when all configurations are explored or when the specified stop condition is fulfilled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the tuned kernel. </td></tr>
    <tr><td class="paramname">stopCondition</td><td>Condition which decides whether to continue the tuning process. See <a class="el" href="classktt_1_1_stop_condition.html">StopCondition</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of results containing information about kernel computation in specific configuration. See <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> for more information. </dd></dl>

</div>
</div>
<a id="ab98c514e83ad83f0ecffb7f1e4b48e34" name="ab98c514e83ad83f0ecffb7f1e4b48e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98c514e83ad83f0ecffb7f1e4b48e34">&#9670;&nbsp;</a></span>TuneIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> ktt::Tuner::TuneIteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_buffer_output_descriptor.html">BufferOutputDescriptor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recomputeReference</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs one step of the tuning process for specified kernel. When this method is called for the kernel for the first time, it creates configuration space based on combinations of provided kernel parameters and constraints. Each time this method is called, it launches a single kernel configuration. If all configurations were already launched, it runs kernel using the best configuration. Output data can be retrieved by providing output descriptors. Allows control over recomputation of reference output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the tuned kernel. </td></tr>
    <tr><td class="paramname">output</td><td>User-provided memory locations for kernel arguments which should be retrieved. See <a class="el" href="classktt_1_1_buffer_output_descriptor.html">BufferOutputDescriptor</a> for more information. </td></tr>
    <tr><td class="paramname">recomputeReference</td><td>Flag which controls whether recomputation of reference output should be performed or not. Useful if kernel data between individual method invocations change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result containing information about kernel computation in specific configuration. See <a class="el" href="classktt_1_1_kernel_result.html">KernelResult</a> for more information. </dd></dl>

</div>
</div>
<a id="a42bfecb3a7da093420dcff86ff3a235f" name="a42bfecb3a7da093420dcff86ff3a235f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bfecb3a7da093420dcff86ff3a235f">&#9670;&nbsp;</a></span>WaitForComputeAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::WaitForComputeAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Blocks until the specified compute action is finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of compute action to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32e8f697b84556c3164575897f7f891a" name="a32e8f697b84556c3164575897f7f891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e8f697b84556c3164575897f7f891a">&#9670;&nbsp;</a></span>WaitForTransferAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::WaitForTransferAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Blocks until the specified buffer transfer action is finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of transfer action to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Source/<a class="el" href="_tuner_8h_source.html">Tuner.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacektt.html">ktt</a></li><li class="navelem"><a class="el" href="classktt_1_1_tuner.html">Tuner</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
