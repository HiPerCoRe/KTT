<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kernel Tuning Toolkit: ktt::ComputeInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kernel Tuning Toolkit
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classktt_1_1_compute_interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classktt_1_1_compute_interface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ktt::ComputeInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_compute_interface_8h_source.html">ComputeInterface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a907624fb3ca339bfba2e7ea9866c5f69"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a907624fb3ca339bfba2e7ea9866c5f69">~ComputeInterface</a> ()=default</td></tr>
<tr class="separator:a907624fb3ca339bfba2e7ea9866c5f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ef7c867d4180088f06e1c3af231138"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#aa9ef7c867d4180088f06e1c3af231138">RunKernel</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id)=0</td></tr>
<tr class="separator:aa9ef7c867d4180088f06e1c3af231138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f59d270724997174613f9fd2006e9a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a6f59d270724997174613f9fd2006e9a4">RunKernel</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)=0</td></tr>
<tr class="separator:a6f59d270724997174613f9fd2006e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa037b0da7fdc94e7deb3bfb0168406ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#aa037b0da7fdc94e7deb3bfb0168406ba">RunKernelAsync</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)=0</td></tr>
<tr class="separator:aa037b0da7fdc94e7deb3bfb0168406ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdca488b872cba7ab7ba5656e18eced7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#acdca488b872cba7ab7ba5656e18eced7">RunKernelAsync</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)=0</td></tr>
<tr class="separator:acdca488b872cba7ab7ba5656e18eced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcdbd900b888751626bd6fe0194d615"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a4dcdbd900b888751626bd6fe0194d615">WaitForComputeAction</a> (const <a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a> id)=0</td></tr>
<tr class="separator:a4dcdbd900b888751626bd6fe0194d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4169242f94362edbc4dbd0f7c41127b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a4169242f94362edbc4dbd0f7c41127b5">RunKernelWithProfiling</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id)=0</td></tr>
<tr class="separator:a4169242f94362edbc4dbd0f7c41127b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66938288a86c1d954a8e89f69c85d81b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a66938288a86c1d954a8e89f69c85d81b">RunKernelWithProfiling</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)=0</td></tr>
<tr class="separator:a66938288a86c1d954a8e89f69c85d81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1a5aad6165ffdba835d40443651c97"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a8d1a5aad6165ffdba835d40443651c97">GetRemainingProfilingRuns</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id) const =0</td></tr>
<tr class="separator:a8d1a5aad6165ffdba835d40443651c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e7566928e755696360228d2e4cbd76"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a52e7566928e755696360228d2e4cbd76">GetRemainingProfilingRuns</a> () const =0</td></tr>
<tr class="separator:a52e7566928e755696360228d2e4cbd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3d80e67b9daa10aee4cb1ec288139b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#abe3d80e67b9daa10aee4cb1ec288139b">GetDefaultQueue</a> () const =0</td></tr>
<tr class="separator:abe3d80e67b9daa10aee4cb1ec288139b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64503830018826609d22e3056de84a18"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a64503830018826609d22e3056de84a18">GetAllQueues</a> () const =0</td></tr>
<tr class="separator:a64503830018826609d22e3056de84a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f15c5a48f396ab20feb26a23baf3482"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue</a> (const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)=0</td></tr>
<tr class="separator:a0f15c5a48f396ab20feb26a23baf3482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c87a68ccfd62d97570bb499447a32b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice</a> ()=0</td></tr>
<tr class="separator:a98c87a68ccfd62d97570bb499447a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d0d3e33c0f1e3e23413176a2008e23"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a46d0d3e33c0f1e3e23413176a2008e23">GetCurrentGlobalSize</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id) const =0</td></tr>
<tr class="separator:a46d0d3e33c0f1e3e23413176a2008e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976e07da2b46dc9af1f0b6ce77b50886"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a976e07da2b46dc9af1f0b6ce77b50886">GetCurrentLocalSize</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id) const =0</td></tr>
<tr class="separator:a976e07da2b46dc9af1f0b6ce77b50886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a74c4be89520607eb4e45c967a8648"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#af5a74c4be89520607eb4e45c967a8648">GetCurrentConfiguration</a> () const =0</td></tr>
<tr class="separator:af5a74c4be89520607eb4e45c967a8648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a4874546d1edfcee7dfe681cbf537"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a145a4874546d1edfcee7dfe681cbf537">ChangeArguments</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;arguments)=0</td></tr>
<tr class="separator:a145a4874546d1edfcee7dfe681cbf537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7e7a9742a11f1ef0ae207d3130312f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a8b7e7a9742a11f1ef0ae207d3130312f">SwapArguments</a> (const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a> id, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> first, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> second)=0</td></tr>
<tr class="separator:a8b7e7a9742a11f1ef0ae207d3130312f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56983712bdc1f2aa982933179b569369"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a56983712bdc1f2aa982933179b569369">UpdateScalarArgument</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *data)=0</td></tr>
<tr class="separator:a56983712bdc1f2aa982933179b569369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9416b26a01b2ce04d334a379e3fa95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#abc9416b26a01b2ce04d334a379e3fa95">UpdateLocalArgument</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const size_t dataSize)=0</td></tr>
<tr class="separator:abc9416b26a01b2ce04d334a379e3fa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f12ca50eac7d870be4cdc5c4d76379a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a0f12ca50eac7d870be4cdc5c4d76379a">UploadBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id)=0</td></tr>
<tr class="separator:a0f12ca50eac7d870be4cdc5c4d76379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcff8d4aa0d638512d9fefe6aa6fe927"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#afcff8d4aa0d638512d9fefe6aa6fe927">UploadBufferAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)=0</td></tr>
<tr class="separator:afcff8d4aa0d638512d9fefe6aa6fe927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ca47ec758904973e2ee458276b1335"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#ad8ca47ec758904973e2ee458276b1335">DownloadBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, void *destination, const size_t dataSize=0)=0</td></tr>
<tr class="separator:ad8ca47ec758904973e2ee458276b1335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6735b4d5e9a50034e9acd1ac5b34cd52"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a6735b4d5e9a50034e9acd1ac5b34cd52">DownloadBufferAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue, void *destination, const size_t dataSize=0)=0</td></tr>
<tr class="separator:a6735b4d5e9a50034e9acd1ac5b34cd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d543715c40557ac22aef493595ee9f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a4d543715c40557ac22aef493595ee9f2">UpdateBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *data, const size_t dataSize=0)=0</td></tr>
<tr class="separator:a4d543715c40557ac22aef493595ee9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82a93622fddc93bd6abe262b3b4f6c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#ae82a93622fddc93bd6abe262b3b4f6c0">UpdateBufferAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue, const void *data, const size_t dataSize=0)=0</td></tr>
<tr class="separator:ae82a93622fddc93bd6abe262b3b4f6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fd4aef75c013bcf70a62c0134f985a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a73fd4aef75c013bcf70a62c0134f985a">CopyBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> destination, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> source, const size_t dataSize=0)=0</td></tr>
<tr class="separator:a73fd4aef75c013bcf70a62c0134f985a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a303fb872e97c6de59cc66ee5aa5b59"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a8a303fb872e97c6de59cc66ee5aa5b59">CopyBufferAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> destination, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> source, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue, const size_t dataSize=0)=0</td></tr>
<tr class="separator:a8a303fb872e97c6de59cc66ee5aa5b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc0fb83da544686a16c7a079afe9c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a2dc0fb83da544686a16c7a079afe9c05">WaitForTransferAction</a> (const <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a> id)=0</td></tr>
<tr class="separator:a2dc0fb83da544686a16c7a079afe9c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd5e6cad0cabf6d747e35acc3ce1b55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a0bd5e6cad0cabf6d747e35acc3ce1b55">ResizeBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const size_t newDataSize, const bool preserveData)=0</td></tr>
<tr class="separator:a0bd5e6cad0cabf6d747e35acc3ce1b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7451f30d523790bbd42792fdd666ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a8d7451f30d523790bbd42792fdd666ca">ClearBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id)=0</td></tr>
<tr class="separator:a8d7451f30d523790bbd42792fdd666ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4d68e723947c2493f74e1e3d89d742"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#abe4d68e723947c2493f74e1e3d89d742">HasBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id)=0</td></tr>
<tr class="separator:abe4d68e723947c2493f74e1e3d89d742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a075573b67aa482409c25a9412ef024"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_compute_interface.html#a5a075573b67aa482409c25a9412ef024">GetUnifiedMemoryBufferHandle</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, <a class="el" href="namespacektt.html#a1f5ef8463df054fbf4aa56f12284a52e">UnifiedBufferMemory</a> &amp;memoryHandle)=0</td></tr>
<tr class="separator:a5a075573b67aa482409c25a9412ef024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for customizing kernel runs in order to run some part of computation on CPU, utilize iterative kernel launches, composite kernels and more. In order to use this functionality, custom kernel launcher function must be defined for the corresponding kernel. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a907624fb3ca339bfba2e7ea9866c5f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907624fb3ca339bfba2e7ea9866c5f69">&#9670;&nbsp;</a></span>~ComputeInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::ComputeInterface::~ComputeInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute interface destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a145a4874546d1edfcee7dfe681cbf537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145a4874546d1edfcee7dfe681cbf537">&#9670;&nbsp;</a></span>ChangeArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::ChangeArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes kernel arguments for the specified kernel definitions under currently launched kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition for which the arguments will be changed. The specified definition must be included in the currently launched kernel. </td></tr>
    <tr><td class="paramname">arguments</td><td>Ids of arguments to be used by the specified kernel definition. The order of ids must match the order of arguments inside kernel function. The provided ids must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d7451f30d523790bbd42792fdd666ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7451f30d523790bbd42792fdd666ca">&#9670;&nbsp;</a></span>ClearBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::ClearBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes compute buffer for the specified vector argument. This method should be used mainly with arguments with <a class="el" href="namespacektt.html#a6c3eb24a8cdc991dd7b7274cc340852f">ArgumentManagementType</a> set to User. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument whose buffer will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73fd4aef75c013bcf70a62c0134f985a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fd4aef75c013bcf70a62c0134f985a">&#9670;&nbsp;</a></span>CopyBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::CopyBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies part of the compute buffer of source vector argument to compute buffer of destination vector argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Id of destination vector argument. </td></tr>
    <tr><td class="paramname">source</td><td>Id of source vector argument. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size in bytes of buffer portion which will be copied to destination buffer, starting with the first byte. If zero, the entire buffer will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a303fb872e97c6de59cc66ee5aa5b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a303fb872e97c6de59cc66ee5aa5b59">&#9670;&nbsp;</a></span>CopyBufferAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a> ktt::ComputeInterface::CopyBufferAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies part of the compute buffer of source vector argument to compute buffer of destination vector argument. The data will be transferred asynchronously in the specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Id of destination vector argument. </td></tr>
    <tr><td class="paramname">source</td><td>Id of source vector argument. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to copy argument will be submitted. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size in bytes of buffer portion which will be copied to destination buffer, starting with the first byte. If zero, the entire buffer will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of asynchronous action corresponding to the issued data transfer command. The action must be waited for with <a class="el" href="classktt_1_1_compute_interface.html#a2dc0fb83da544686a16c7a079afe9c05">WaitForTransferAction()</a>, <a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue()</a> or <a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice()</a> methods. Otherwise, problems such as incorrectly recorded kernel durations may occur. </dd></dl>

</div>
</div>
<a id="ad8ca47ec758904973e2ee458276b1335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ca47ec758904973e2ee458276b1335">&#9670;&nbsp;</a></span>DownloadBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::DownloadBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Downloads the specified vector argument from compute buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be downloaded. </td></tr>
    <tr><td class="paramname">destination</td><td>Buffer where the argument data will be downloaded. Its size must be equal or greater than the specified data size. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size in bytes of buffer portion which will be downloaded to specified destination, starting with the first byte. If zero, the entire buffer will be downloaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6735b4d5e9a50034e9acd1ac5b34cd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6735b4d5e9a50034e9acd1ac5b34cd52">&#9670;&nbsp;</a></span>DownloadBufferAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a> ktt::ComputeInterface::DownloadBufferAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Downloads the specified vector argument from compute buffer. The data will be transferred asynchronously in the specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be downloaded. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to download argument will be submitted. </td></tr>
    <tr><td class="paramname">destination</td><td>Buffer where the argument data will be downloaded. Its size must be equal or greater than the specified data size. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size in bytes of buffer portion which will be downloaded to specified destination, starting with the first byte. If zero, the entire buffer will be downloaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of asynchronous action corresponding to the issued data transfer command. The action must be waited for with <a class="el" href="classktt_1_1_compute_interface.html#a2dc0fb83da544686a16c7a079afe9c05">WaitForTransferAction()</a>, <a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue()</a> or <a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice()</a> methods. Otherwise, problems such as incorrectly recorded kernel durations may occur. </dd></dl>

</div>
</div>
<a id="a64503830018826609d22e3056de84a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64503830018826609d22e3056de84a18">&#9670;&nbsp;</a></span>GetAllQueues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> &gt; ktt::ComputeInterface::GetAllQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves ids of all available device queues. Number of queues can be specified during tuner creation. </p><dl class="section return"><dt>Returns</dt><dd>Ids of all available device queues. </dd></dl>

</div>
</div>
<a id="af5a74c4be89520607eb4e45c967a8648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a74c4be89520607eb4e45c967a8648">&#9670;&nbsp;</a></span>GetCurrentConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> &amp; ktt::ComputeInterface::GetCurrentConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns configuration of the currently launched kernel. </p><dl class="section return"><dt>Returns</dt><dd>Configuration of the currently launched kernel. See <a class="el" href="classktt_1_1_kernel_configuration.html">KernelConfiguration</a> for more information. </dd></dl>

</div>
</div>
<a id="a46d0d3e33c0f1e3e23413176a2008e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d0d3e33c0f1e3e23413176a2008e23">&#9670;&nbsp;</a></span>GetCurrentGlobalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp; ktt::ComputeInterface::GetCurrentGlobalSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns global thread size for the specified kernel definition based on the current configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition for which the global size will be retrieved. The specified definition must be included in the currently launched kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global thread size of the specified kernel definition. </dd></dl>

</div>
</div>
<a id="a976e07da2b46dc9af1f0b6ce77b50886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976e07da2b46dc9af1f0b6ce77b50886">&#9670;&nbsp;</a></span>GetCurrentLocalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp; ktt::ComputeInterface::GetCurrentLocalSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns local thread size for the specified kernel definition based on the current configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition for which the local size will be retrieved. The specified definition must be included in the currently launched kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Local thread size of the specified kernel definition. </dd></dl>

</div>
</div>
<a id="abe3d80e67b9daa10aee4cb1ec288139b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3d80e67b9daa10aee4cb1ec288139b">&#9670;&nbsp;</a></span>GetDefaultQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> ktt::ComputeInterface::GetDefaultQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves id of default device queue. All synchronous commands are submitted to this queue. </p><dl class="section return"><dt>Returns</dt><dd>Id of default device queue. </dd></dl>

</div>
</div>
<a id="a52e7566928e755696360228d2e4cbd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e7566928e755696360228d2e4cbd76">&#9670;&nbsp;</a></span>GetRemainingProfilingRuns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ktt::ComputeInterface::GetRemainingProfilingRuns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves number of remaining profiling runs that are needed to collect all the profiling counters for the currently launched kernel. The number is derived from included kernel definitions which have kernel profiling functionality enabled. </p><dl class="section return"><dt>Returns</dt><dd>Number of remaining profiling runs. Note that if no profiling runs were run so far, zero is returned. </dd></dl>

</div>
</div>
<a id="a8d1a5aad6165ffdba835d40443651c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1a5aad6165ffdba835d40443651c97">&#9670;&nbsp;</a></span>GetRemainingProfilingRuns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ktt::ComputeInterface::GetRemainingProfilingRuns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves number of remaining profiling runs that are needed to collect all the profiling counters for the specified kernel definition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition for which the number of remaining profiling runs will be retrieved. The specified definition must be included in the currently launched kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of remaining profiling runs. Note that if no profiling runs were run so far for the specified definition, zero is returned. </dd></dl>

</div>
</div>
<a id="a5a075573b67aa482409c25a9412ef024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a075573b67aa482409c25a9412ef024">&#9670;&nbsp;</a></span>GetUnifiedMemoryBufferHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::GetUnifiedMemoryBufferHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a1f5ef8463df054fbf4aa56f12284a52e">UnifiedBufferMemory</a> &amp;&#160;</td>
          <td class="paramname"><em>memoryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves memory handle for the specified unified memory argument. The handle can be used to manipulate argument memory on host side. Example usage: <a class="el" href="namespacektt.html#a1f5ef8463df054fbf4aa56f12284a52e">ktt::UnifiedBufferMemory</a> memory; GetUnifiedMemoryBufferHandle(..., memory); float* floatArray = static_cast&lt;float*&gt;(memory); </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument whose memory handle will be retrieved. </td></tr>
    <tr><td class="paramname">memoryHandle</td><td>Location where the memory handle will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe4d68e723947c2493f74e1e3d89d742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4d68e723947c2493f74e1e3d89d742">&#9670;&nbsp;</a></span>HasBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ktt::ComputeInterface::HasBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether compute buffer for the specified vector argument exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer for argument exists. False otherwise. </dd></dl>

</div>
</div>
<a id="a0bd5e6cad0cabf6d747e35acc3ce1b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd5e6cad0cabf6d747e35acc3ce1b55">&#9670;&nbsp;</a></span>ResizeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::ResizeBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserveData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes compute buffer for the specified vector argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument whose buffer will be resized. </td></tr>
    <tr><td class="paramname">newDataSize</td><td>Size in bytes for the resized buffer. </td></tr>
    <tr><td class="paramname">preserveData</td><td>If true, data from the old buffer will be copied into resized buffer. If false, the old data will be discarded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9ef7c867d4180088f06e1c3af231138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ef7c867d4180088f06e1c3af231138">&#9670;&nbsp;</a></span>RunKernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::RunKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the specified kernel definition using thread sizes based on the current configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition which will be run. The specified definition must be included in the currently launched kernel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f59d270724997174613f9fd2006e9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f59d270724997174613f9fd2006e9a4">&#9670;&nbsp;</a></span>RunKernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::RunKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the specified kernel definition using provided thread sizes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition which will be run. The specified definition must be included in the currently launched kernel. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for global size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for local size with which the kernel will be run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa037b0da7fdc94e7deb3bfb0168406ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa037b0da7fdc94e7deb3bfb0168406ba">&#9670;&nbsp;</a></span>RunKernelAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a> ktt::ComputeInterface::RunKernelAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the specified kernel definition using thread sizes based on the current configuration. The kernel will be launched asynchronously in the specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition which will be run. The specified definition must be included in the currently launched kernel. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to run kernel will be submitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of asynchronous action corresponding to the issued kernel run command. The action must be waited for with <a class="el" href="classktt_1_1_compute_interface.html#a4dcdbd900b888751626bd6fe0194d615">WaitForComputeAction()</a>, <a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue()</a> or <a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice()</a> methods. Otherwise, problems such as incorrectly recorded kernel durations may occur. </dd></dl>

</div>
</div>
<a id="acdca488b872cba7ab7ba5656e18eced7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdca488b872cba7ab7ba5656e18eced7">&#9670;&nbsp;</a></span>RunKernelAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a> ktt::ComputeInterface::RunKernelAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the specified kernel definition using provided thread sizes. The kernel will be launched asynchronously in the specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition which will be run. The specified definition must be included in the currently launched kernel. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to run kernel will be submitted. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for global size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for local size with which the kernel will be run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of asynchronous action corresponding to the issued kernel run command. The action must be waited for with <a class="el" href="classktt_1_1_compute_interface.html#a4dcdbd900b888751626bd6fe0194d615">WaitForComputeAction()</a>, <a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue()</a> or <a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice()</a> methods. Otherwise, problems such as incorrectly recorded kernel durations may occur. </dd></dl>

</div>
</div>
<a id="a4169242f94362edbc4dbd0f7c41127b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4169242f94362edbc4dbd0f7c41127b5">&#9670;&nbsp;</a></span>RunKernelWithProfiling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::RunKernelWithProfiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the specified kernel definition using thread sizes based on the current configuration. Collection of kernel profiling counters will be enabled for this run which means that performance will be decreased. Running kernels with profiling will always cause implicit device synchronization before and after the kernel run is finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition which will be run. The specified definition must be included in the currently launched kernel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66938288a86c1d954a8e89f69c85d81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66938288a86c1d954a8e89f69c85d81b">&#9670;&nbsp;</a></span>RunKernelWithProfiling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::RunKernelWithProfiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the specified kernel definition using provided thread sizes. Collection of kernel profiling counters will be enabled for this run which means that performance will be decreased. Running kernels with profiling will always cause implicit device synchronization before and after the kernel run is finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition which will be run. The specified definition must be included in the currently launched kernel. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for global size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for local size with which the kernel will be run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7e7a9742a11f1ef0ae207d3130312f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7e7a9742a11f1ef0ae207d3130312f">&#9670;&nbsp;</a></span>SwapArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::SwapArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#af036bcbcbd9130d73d96c148af4b38a5">KernelDefinitionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps positions of kernel arguments for the specified kernel definition under currently launched kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel definition for which the arguments will be swapped. The specified definition must be included in the currently launched kernel. </td></tr>
    <tr><td class="paramname">first</td><td>Id of the first argument which will be swapped. </td></tr>
    <tr><td class="paramname">second</td><td>Id of the second argument which will be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98c87a68ccfd62d97570bb499447a32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c87a68ccfd62d97570bb499447a32b">&#9670;&nbsp;</a></span>SynchronizeDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::SynchronizeDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until all commands submitted to all device queues are completed. </p>

</div>
</div>
<a id="a0f15c5a48f396ab20feb26a23baf3482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f15c5a48f396ab20feb26a23baf3482">&#9670;&nbsp;</a></span>SynchronizeQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::SynchronizeQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until all commands submitted to the specified device queue are completed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Id of queue which will be synchronized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d543715c40557ac22aef493595ee9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d543715c40557ac22aef493595ee9f2">&#9670;&nbsp;</a></span>UpdateBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::UpdateBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates data in compute buffer of the specified vector argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be updated. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to new data for vector argument. Its size must be equal or greater than the specified data size. The data must have matching kernel argument data type. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size in bytes of buffer portion which will be updated, starting with the first byte. If zero, the entire buffer will be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae82a93622fddc93bd6abe262b3b4f6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82a93622fddc93bd6abe262b3b4f6c0">&#9670;&nbsp;</a></span>UpdateBufferAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a> ktt::ComputeInterface::UpdateBufferAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates data in compute buffer of the specified vector argument. The data will be transferred asynchronously in the specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be updated. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to update argument will be submitted. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to new data for vector argument. Its size must be equal or greater than the specified data size. The data must have matching kernel argument data type. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size in bytes of buffer portion which will be updated, starting with the first byte. If zero, the entire buffer will be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of asynchronous action corresponding to the issued data transfer command. The action must be waited for with <a class="el" href="classktt_1_1_compute_interface.html#a2dc0fb83da544686a16c7a079afe9c05">WaitForTransferAction()</a>, <a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue()</a> or <a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice()</a> methods. Otherwise, problems such as incorrectly recorded kernel durations may occur. </dd></dl>

</div>
</div>
<a id="abc9416b26a01b2ce04d334a379e3fa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9416b26a01b2ce04d334a379e3fa95">&#9670;&nbsp;</a></span>UpdateLocalArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::UpdateLocalArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the specified local memory argument under currently launched kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of local memory argument which will be updated. </td></tr>
    <tr><td class="paramname">dataSize</td><td>New size in bytes for the argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56983712bdc1f2aa982933179b569369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56983712bdc1f2aa982933179b569369">&#9670;&nbsp;</a></span>UpdateScalarArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::UpdateScalarArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the specified scalar argument under currently launched kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of scalar argument which will be updated. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to new data for scalar argument. The data must have matching kernel argument data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f12ca50eac7d870be4cdc5c4d76379a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f12ca50eac7d870be4cdc5c4d76379a">&#9670;&nbsp;</a></span>UploadBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::UploadBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uploads the specified vector argument into compute buffer. This method should be used mainly with arguments with <a class="el" href="namespacektt.html#a6c3eb24a8cdc991dd7b7274cc340852f">ArgumentManagementType</a> set to User. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be uploaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcff8d4aa0d638512d9fefe6aa6fe927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcff8d4aa0d638512d9fefe6aa6fe927">&#9670;&nbsp;</a></span>UploadBufferAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a> ktt::ComputeInterface::UploadBufferAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uploads the specified vector argument into compute buffer. The data will be transferred asynchronously in the specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be uploaded. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to upload argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of asynchronous action corresponding to the issued data transfer command. The action must be waited for with <a class="el" href="classktt_1_1_compute_interface.html#a2dc0fb83da544686a16c7a079afe9c05">WaitForTransferAction()</a>, <a class="el" href="classktt_1_1_compute_interface.html#a0f15c5a48f396ab20feb26a23baf3482">SynchronizeQueue()</a> or <a class="el" href="classktt_1_1_compute_interface.html#a98c87a68ccfd62d97570bb499447a32b">SynchronizeDevice()</a> methods. Otherwise, problems such as incorrectly recorded kernel durations may occur. </dd></dl>

</div>
</div>
<a id="a4dcdbd900b888751626bd6fe0194d615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcdbd900b888751626bd6fe0194d615">&#9670;&nbsp;</a></span>WaitForComputeAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::WaitForComputeAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a2b7801a49d987ff600bfdf06ddcbacf4">ComputeActionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until the specified compute action is finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of compute action to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dc0fb83da544686a16c7a079afe9c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc0fb83da544686a16c7a079afe9c05">&#9670;&nbsp;</a></span>WaitForTransferAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::ComputeInterface::WaitForTransferAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a90efa06798a7148f493e206ae3a3d410">TransferActionId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until the specified buffer transfer action is finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of transfer action to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Source/Api/<a class="el" href="_compute_interface_8h_source.html">ComputeInterface.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacektt.html">ktt</a></li><li class="navelem"><a class="el" href="classktt_1_1_compute_interface.html">ComputeInterface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
